<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Command line parameter overview.</title>
</head>
<body>
<!--WARNING: THIS DOCUMENT IS AUTOMATICALLY GENERATED. MODIFICATIONS MAY GET LOST.-->
<h1>ELKI command line parameter overview:</h1>
<dl>
<dt>
<a name="de.lmu.ifi.dbs.elki.KDDTask"/>
<a href="de/lmu/ifi/dbs/elki/KDDTask.html">de.lmu.ifi.dbs.elki.KDDTask</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm</tt>
</dt>
<dd>Algorithm to run.<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.Algorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.):<br/>-&gt; outlier.COP<br/>-&gt; outlier.GeneralizedLOF<br/>-&gt; outlier.LOF<br/>-&gt; APRIORI<br/>-&gt; DependencyDerivator<br/>-&gt; KNNDistanceOrder<br/>-&gt; KNNJoin<br/>-&gt; classifier.CorrelationBasedClassifier<br/>-&gt; classifier.KNNClassifier<br/>-&gt; classifier.PriorProbabilityClassifier<br/>-&gt; clustering.DBSCAN<br/>-&gt; clustering.DeLiClu<br/>-&gt; clustering.EM<br/>-&gt; clustering.KMeans<br/>-&gt; clustering.OPTICS<br/>-&gt; clustering.SLINK<br/>-&gt; clustering.SNNClustering<br/>-&gt; clustering.ByLabelClustering<br/>-&gt; clustering.TrivialAllInOne<br/>-&gt; clustering.TrivialAllNoise<br/>-&gt; clustering.correlation.CASH<br/>-&gt; clustering.correlation.COPAC<br/>-&gt; clustering.correlation.ERiC<br/>-&gt; clustering.correlation.FourC<br/>-&gt; clustering.correlation.ORCLUS<br/>-&gt; clustering.subspace.CLIQUE<br/>-&gt; clustering.subspace.DiSH<br/>-&gt; clustering.subspace.PreDeCon<br/>-&gt; clustering.subspace.PROCLUS</dd>
<dt>
<tt>-dbc</tt>
</dt>
<dd>Database connection class.<br/>Implementing de.lmu.ifi.dbs.elki.database.connection.DatabaseConnection<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.connection.):<br/>-&gt; FileBasedDatabaseConnection<br/>-&gt; InputStreamDatabaseConnection<br/>-&gt; MultipleFileBasedDatabaseConnection<br/>Default: de.lmu.ifi.dbs.elki.database.connection.FileBasedDatabaseConnection.</dd>
<dt>
<tt>-description</tt>
</dt>
<dd>Class to obtain a description of. Causes immediate stop of the program.<br/>Implementing de.lmu.ifi.dbs.elki.utilities.optionhandling.Parameterizable</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-norm</tt>
</dt>
<dd>Normalization class in order to normalize values in the database.<br/>Implementing de.lmu.ifi.dbs.elki.normalization.Normalization<br/>Known classes (default package de.lmu.ifi.dbs.elki.normalization.):<br/>-&gt; AttributeWiseRealVectorNormalization<br/>-&gt; DummyNormalization<br/>-&gt; MultiRepresentedObjectNormalization</dd>
<dt>
<tt>-normUndo</tt>
</dt>
<dd>Revert normalization result to original values - invalid option if no normalization has been performed.</dd>
<dt>
<tt>-resulthandler</tt>
</dt>
<dd>Result handler class.<br/>Implementing de.lmu.ifi.dbs.elki.result.ResultHandler<br/>Known classes (default package de.lmu.ifi.dbs.elki.result.):<br/>-&gt; ResultWriter<br/>-&gt; DiscardResultHandler<br/>Default: de.lmu.ifi.dbs.elki.result.ResultWriter.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.APRIORI"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/APRIORI.html">de.lmu.ifi.dbs.elki.algorithm.APRIORI</a>
</dt>
<dd>
<dl>
<dt>
<tt>-apriori.minfreq</tt>
</dt>
<dd>Threshold for minimum frequency as percentage value (alternatively to parameter apriori.minsupp).<br/>Constraint: apriori.minfreq in [0, 1].</dd>
<dt>
<tt>-apriori.minsupp</tt>
</dt>
<dd>Threshold for minimum support as minimally required number of transactions (alternatively to parameter apriori.minfreq - setting apriori.minsupp is slightly preferable over setting apriori.minfreq in terms of efficiency).<br/>Constraint: apriori.minsupp &gt;= 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.DependencyDerivator"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/DependencyDerivator.html">de.lmu.ifi.dbs.elki.algorithm.DependencyDerivator</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-derivator.accuracy</tt>
</dt>
<dd>Threshold for output accuracy fraction digits.<br/>Default: 4.<br/>Constraint: derivator.accuracy &gt;= 0.</dd>
<dt>
<tt>-derivator.randomSample</tt>
</dt>
<dd>Flag to use random sample (use knn query around centroid, if flag is not set).</dd>
<dt>
<tt>-derivator.sampleSize</tt>
</dt>
<dd>Threshold for the size of the random sample to use. Default value is size of the complete dataset.<br/>Constraint: derivator.sampleSize &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-derivator.accuracy</tt>
</dt>
<dd>Threshold for output accuracy fraction digits.<br/>Default: 4.<br/>Constraint: derivator.accuracy &gt;= 0.</dd>
<dt>
<tt>-derivator.randomSample</tt>
</dt>
<dd>Flag to use random sample (use knn query around centroid, if flag is not set).</dd>
<dt>
<tt>-derivator.sampleSize</tt>
</dt>
<dd>Threshold for the size of the random sample to use. Default value is size of the complete dataset.<br/>Constraint: derivator.sampleSize &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.DummyAlgorithm"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/DummyAlgorithm.html">de.lmu.ifi.dbs.elki.algorithm.DummyAlgorithm</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.KNNDistanceOrder"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/KNNDistanceOrder.html">de.lmu.ifi.dbs.elki.algorithm.KNNDistanceOrder</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-knndistanceorder.k</tt>
</dt>
<dd>Specifies the distance of the k-distant object to be assessed.<br/>Default: 1.<br/>Constraint: knndistanceorder.k &gt; 0.</dd>
<dt>
<tt>-knndistanceorder.percentage</tt>
</dt>
<dd>The average percentage of distances randomly choosen to be provided in the result.<br/>Default: 1.0.<br/>Constraint: knndistanceorder.percentage in (0, 1].</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.KNNJoin"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/KNNJoin.html">de.lmu.ifi.dbs.elki.algorithm.KNNJoin</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-knnjoin.k</tt>
</dt>
<dd>Specifies the k-nearest neighbors to be assigned.<br/>Default: 1.<br/>Constraint: knnjoin.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.MaterializeDistances"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/MaterializeDistances.html">de.lmu.ifi.dbs.elki.algorithm.MaterializeDistances</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.NullAlgorithm"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/NullAlgorithm.html">de.lmu.ifi.dbs.elki.algorithm.NullAlgorithm</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.classifier.CorrelationBasedClassifier"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/classifier/CorrelationBasedClassifier.html">de.lmu.ifi.dbs.elki.algorithm.classifier.CorrelationBasedClassifier</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.classifier.KNNClassifier"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/classifier/KNNClassifier.html">de.lmu.ifi.dbs.elki.algorithm.classifier.KNNClassifier</a>
</dt>
<dd>
<dl>
<dt>
<tt>-classifier.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-knnclassifier.k</tt>
</dt>
<dd>The number of neighbors to take into account for classification.<br/>Default: 1.<br/>Constraint: knnclassifier.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.classifier.PriorProbabilityClassifier"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/classifier/PriorProbabilityClassifier.html">de.lmu.ifi.dbs.elki.algorithm.classifier.PriorProbabilityClassifier</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.ByLabelClustering"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/ByLabelClustering.html">de.lmu.ifi.dbs.elki.algorithm.clustering.ByLabelClustering</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.ByLabelHierarchicalClustering"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/ByLabelHierarchicalClustering.html">de.lmu.ifi.dbs.elki.algorithm.clustering.ByLabelHierarchicalClustering</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.DBSCAN"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/DBSCAN.html">de.lmu.ifi.dbs.elki.algorithm.clustering.DBSCAN</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-dbscan.minpts</tt>
</dt>
<dd> Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: dbscan.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.DeLiClu"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/DeLiClu.html">de.lmu.ifi.dbs.elki.algorithm.clustering.DeLiClu</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-deliclu.minpts</tt>
</dt>
<dd>Threshold for minimum number of points within a cluster.<br/>Constraint: deliclu.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.EM"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/EM.html">de.lmu.ifi.dbs.elki.algorithm.clustering.EM</a>
</dt>
<dd>
<dl>
<dt>
<tt>-em.delta</tt>
</dt>
<dd>The termination criterion for maximization of E(M): E(M) - E(M') &lt; em.delta<br/>Default: 0.0.<br/>Constraint: em.delta &gt;= 0.0.</dd>
<dt>
<tt>-em.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: em.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.KMeans"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/KMeans.html">de.lmu.ifi.dbs.elki.algorithm.clustering.KMeans</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-kmeans.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: kmeans.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.OPTICS"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/OPTICS.html">de.lmu.ifi.dbs.elki.algorithm.clustering.OPTICS</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-optics.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-optics.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: optics.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.SLINK"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/SLINK.html">de.lmu.ifi.dbs.elki.algorithm.clustering.SLINK</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.SNNClustering"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/SNNClustering.html">de.lmu.ifi.dbs.elki.algorithm.clustering.SNNClustering</a>
</dt>
<dd>
<dl>
<dt>
<tt>-snn.epsilon</tt>
</dt>
<dd>The minimum SNN density.<br/>Constraint: snn.epsilon &gt; 0.</dd>
<dt>
<tt>-snn.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-SNN-neighborhood of a point.<br/>Constraint: snn.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.TrivialAllInOne"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/TrivialAllInOne.html">de.lmu.ifi.dbs.elki.algorithm.clustering.TrivialAllInOne</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.TrivialAllNoise"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/TrivialAllNoise.html">de.lmu.ifi.dbs.elki.algorithm.clustering.TrivialAllNoise</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.CASH"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/correlation/CASH.html">de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.CASH</a>
</dt>
<dd>
<dl>
<dt>
<tt>-cash.adjust</tt>
</dt>
<dd>Flag to indicate that an adjustment of the applied heuristic for choosing an interval is performed after an interval is selected.</dd>
<dt>
<tt>-cash.jitter</tt>
</dt>
<dd>The maximum jitter for distance values.<br/>Constraint: cash.jitter &gt; 0.</dd>
<dt>
<tt>-cash.maxlevel</tt>
</dt>
<dd>The maximum level for splitting the hypercube.<br/>Constraint: cash.maxlevel &gt; 0.</dd>
<dt>
<tt>-cash.mindim</tt>
</dt>
<dd>The minimum dimensionality of the subspaces to be found.<br/>Default: 1.<br/>Constraint: cash.mindim &gt; 0.</dd>
<dt>
<tt>-cash.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in a cluster.<br/>Constraint: cash.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.COPAC"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/correlation/COPAC.html">de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.COPAC</a>
</dt>
<dd>
<dl>
<dt>
<tt>-copac.partitionAlgorithm</tt>
</dt>
<dd>Clustering algorithm to apply to each partition.<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.clustering.ClusteringAlgorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.clustering.):<br/>-&gt; correlation.COPAC<br/>-&gt; DBSCAN<br/>-&gt; EM<br/>-&gt; KMeans<br/>-&gt; SNNClustering<br/>-&gt; correlation.COPAC<br/>-&gt; correlation.FourC<br/>-&gt; correlation.ORCLUS<br/>-&gt; subspace.CLIQUE<br/>-&gt; subspace.PreDeCon<br/>-&gt; subspace.PROCLUS</dd>
<dt>
<tt>-copac.partitionDB</tt>
</dt>
<dd>Database class for each partition. If this parameter is not set, the databases of the partitions have the same class as the original database.<br/>Implementing de.lmu.ifi.dbs.elki.database.Database<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.):<br/>-&gt; MetricalIndexDatabase<br/>-&gt; SequentialDatabase<br/>-&gt; SpatialIndexDatabase</dd>
<dt>
<tt>-copac.preprocessor</tt>
</dt>
<dd>Preprocessor to derive partition criterion.<br/>Extending de.lmu.ifi.dbs.elki.preprocessing.HiCOPreprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; KnnQueryBasedHiCOPreprocessor<br/>-&gt; RangeQueryBasedHiCOPreprocessor</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.ERiC"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/correlation/ERiC.html">de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.ERiC</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.FourC"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/correlation/FourC.html">de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.FourC</a>
</dt>
<dd>
<dl>
<dt>
<tt>-projdbscan.distancefunction</tt>
</dt>
<dd>Distance function to determine the neighbors for variance analysis.<br/>Extending de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction</dd>
<dt>
<tt>-projdbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-projdbscan.lambda</tt>
</dt>
<dd>The intrinsic dimensionality of the clusters to find.<br/>Constraint: projdbscan.lambda &gt; 0.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.KernelFourC"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/correlation/KernelFourC.html">de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.KernelFourC</a>
</dt>
<dd>
<dl>
<dt>
<tt>-projdbscan.distancefunction</tt>
</dt>
<dd>Distance function to determine the neighbors for variance analysis.<br/>Extending de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction</dd>
<dt>
<tt>-projdbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-projdbscan.lambda</tt>
</dt>
<dd>The intrinsic dimensionality of the clusters to find.<br/>Constraint: projdbscan.lambda &gt; 0.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.ORCLUS"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/correlation/ORCLUS.html">de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.ORCLUS</a>
</dt>
<dd>
<dl>
<dt>
<tt>-orclus.alpha</tt>
</dt>
<dd>The factor for reducing the number of current clusters in each iteration.<br/>Default: 0.5.<br/>Constraint: orclus.alpha in (0, 1].</dd>
<dt>
<tt>-projectedclustering.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: projectedclustering.k &gt; 0.</dd>
<dt>
<tt>-projectedclustering.k_i</tt>
</dt>
<dd>The multiplier for the initial number of seeds.<br/>Default: 30.<br/>Constraint: projectedclustering.k_i &gt; 0.</dd>
<dt>
<tt>-projectedclustering.l</tt>
</dt>
<dd>The dimensionality of the clusters to find.<br/>Constraint: projectedclustering.l &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.subspace.CLIQUE"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/subspace/CLIQUE.html">de.lmu.ifi.dbs.elki.algorithm.clustering.subspace.CLIQUE</a>
</dt>
<dd>
<dl>
<dt>
<tt>-clique.prune</tt>
</dt>
<dd>Flag to indicate that only subspaces with large coverage (i.e. the fraction of the database that is covered by the dense units) are selected, the rest will be pruned.</dd>
<dt>
<tt>-clique.tau</tt>
</dt>
<dd>The density threshold for the selectivity of a unit, where the selectivity isthe fraction of total feature vectors contained in this unit.<br/>Constraint: clique.tau in (0, 1).</dd>
<dt>
<tt>-clique.xsi</tt>
</dt>
<dd>The number of intervals (units) in each dimension.<br/>Constraint: clique.xsi &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.subspace.DiSH"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/subspace/DiSH.html">de.lmu.ifi.dbs.elki.algorithm.clustering.subspace.DiSH</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dish.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered in each dimension for determination of the preference vector.<br/>Default: 0.0010.<br/>Constraint: dish.epsilon &gt;= 0.</dd>
<dt>
<tt>-dish.mu</tt>
</dt>
<dd>The minimum number of points as a smoothing factor to avoid the single-link-effekt.<br/>Default: 1.<br/>Constraint: dish.mu &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.subspace.PROCLUS"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/subspace/PROCLUS.html">de.lmu.ifi.dbs.elki.algorithm.clustering.subspace.PROCLUS</a>
</dt>
<dd>
<dl>
<dt>
<tt>-proclus.mi</tt>
</dt>
<dd>The multiplier for the initial number of medoids.<br/>Default: 10.<br/>Constraint: proclus.mi &gt; 0.</dd>
<dt>
<tt>-projectedclustering.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: projectedclustering.k &gt; 0.</dd>
<dt>
<tt>-projectedclustering.k_i</tt>
</dt>
<dd>The multiplier for the initial number of seeds.<br/>Default: 30.<br/>Constraint: projectedclustering.k_i &gt; 0.</dd>
<dt>
<tt>-projectedclustering.l</tt>
</dt>
<dd>The dimensionality of the clusters to find.<br/>Constraint: projectedclustering.l &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.clustering.subspace.PreDeCon"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/clustering/subspace/PreDeCon.html">de.lmu.ifi.dbs.elki.algorithm.clustering.subspace.PreDeCon</a>
</dt>
<dd>
<dl>
<dt>
<tt>-projdbscan.distancefunction</tt>
</dt>
<dd>Distance function to determine the neighbors for variance analysis.<br/>Extending de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction</dd>
<dt>
<tt>-projdbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-projdbscan.lambda</tt>
</dt>
<dd>The intrinsic dimensionality of the clusters to find.<br/>Constraint: projdbscan.lambda &gt; 0.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.outlier.ABOD"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/outlier/ABOD.html">de.lmu.ifi.dbs.elki.algorithm.outlier.ABOD</a>
</dt>
<dd>
<dl>
<dt>
<tt>-abod.fast</tt>
</dt>
<dd>Flag to indicate that the algorithm should run the fast/approximative version.</dd>
<dt>
<tt>-abod.k</tt>
</dt>
<dd>Parameter k for kNN queries.<br/>Default: 30.<br/>Constraint: abod.k &gt;= 1.</dd>
<dt>
<tt>-abod.kernelfunction</tt>
</dt>
<dd>Kernel function to use.<br/>Implementing de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.KernelFunctionDefault: de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.PolynomialKernelFunction.</dd>
<dt>
<tt>-abod.samplesize</tt>
</dt>
<dd>Sample size to use in fast mode.<br/>Constraint: abod.samplesize &gt;= 1.</dd>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.outlier.COP"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/outlier/COP.html">de.lmu.ifi.dbs.elki.algorithm.outlier.COP</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-cop.k</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its COP_SCORE.<br/>Constraint: cop.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.outlier.GeneralizedLOF"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/outlier/GeneralizedLOF.html">de.lmu.ifi.dbs.elki.algorithm.outlier.GeneralizedLOF</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-genlof.k</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its LOF_SCORE.<br/>Constraint: genlof.k &gt; 1.</dd>
<dt>
<tt>-genlof.reachdistfunction</tt>
</dt>
<dd>Distance function to determine the reachability distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.outlier.LOCI"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/outlier/LOCI.html">de.lmu.ifi.dbs.elki.algorithm.outlier.LOCI</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-loci.alpha</tt>
</dt>
<dd>Scaling factor for averaging neighborhood</dd>
<dt>
<tt>-loci.nmin</tt>
</dt>
<dd>Minimum neighborhood size to be considered.<br/>Default: 20.</dd>
<dt>
<tt>-loci.rmax</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.outlier.LOF"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/outlier/LOF.html">de.lmu.ifi.dbs.elki.algorithm.outlier.LOF</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-lof.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: lof.cachesize &gt; 0.</dd>
<dt>
<tt>-lof.minpts</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its LOF.<br/>Constraint: lof.minpts &gt; 0.</dd>
<dt>
<tt>-lof.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: lof.pagesize &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.outlier.OnlineLOF"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/outlier/OnlineLOF.html">de.lmu.ifi.dbs.elki.algorithm.outlier.OnlineLOF</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-lof.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: lof.cachesize &gt; 0.</dd>
<dt>
<tt>-lof.minpts</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its LOF.<br/>Constraint: lof.minpts &gt; 0.</dd>
<dt>
<tt>-lof.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: lof.pagesize &gt; 0.</dd>
<dt>
<tt>-onlinelof.insertions</tt>
</dt>
<dd>The name of the file containing the objects to be inserted.</dd>
<dt>
<tt>-onlinelof.lof</tt>
</dt>
<dd>The name of the file containing the LOFs of the input file.</dd>
<dt>
<tt>-onlinelof.nn</tt>
</dt>
<dd>The name of the file containing the nearest neighbors of the input file.</dd>
<dt>
<tt>-onlinelof.parser</tt>
</dt>
<dd>Parser to parse the insertion and/or deletion files.<br/>Implementing de.lmu.ifi.dbs.elki.parser.Parser<br/>Known classes (default package de.lmu.ifi.dbs.elki.parser.):<br/>-&gt; BitVectorLabelParser<br/>-&gt; NumberDistanceParser<br/>-&gt; ParameterizationFunctionLabelParser<br/>-&gt; DoubleVectorLabelParser<br/>-&gt; FloatVectorLabelParser<br/>-&gt; DoubleVectorLabelTransposingParser<br/>-&gt; SparseBitVectorLabelParser<br/>Default: de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.outlier.SOD"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/outlier/SOD.html">de.lmu.ifi.dbs.elki.algorithm.outlier.SOD</a>
</dt>
<dd>
<dl>
<dt>
<tt>-sod.alpha</tt>
</dt>
<dd>The multiplier for the discriminance value for discerning small from large variances.<br/>Default: 1.1.<br/>Constraint: sod.alpha &gt; 0.</dd>
<dt>
<tt>-sod.knn</tt>
</dt>
<dd>The number of shared nearest neighbors to be considered for learning the subspace properties.<br/>Default: 1.<br/>Constraint: sod.knn &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.statistics.DistanceStatisticsWithClasses"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/statistics/DistanceStatisticsWithClasses.html">de.lmu.ifi.dbs.elki.algorithm.statistics.DistanceStatisticsWithClasses</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-diststat.sampling</tt>
</dt>
<dd>Enable sampling to reduce runtime from O(2*n*n) to O(n*n)+O(n) at the cost of evenutally having more than the configured number of bins.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.statistics.EvaluateRankingQuality"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/statistics/EvaluateRankingQuality.html">de.lmu.ifi.dbs.elki.algorithm.statistics.EvaluateRankingQuality</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.algorithm.statistics.RankingQualityHistogram"/>
<a href="de/lmu/ifi/dbs/elki/algorithm/statistics/RankingQualityHistogram.html">de.lmu.ifi.dbs.elki.algorithm.statistics.RankingQualityHistogram</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.converter.Arff2Txt"/>
<a href="de/lmu/ifi/dbs/elki/converter/Arff2Txt.html">de.lmu.ifi.dbs.elki.converter.Arff2Txt</a>
</dt>
<dd>
<dl>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.in</tt>
</dt>
<dd>The name of the arff-file to convert.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>the txt-file to write the converted arff-file in.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.converter.ArffSparseInstanceToSparseBitVector"/>
<a href="de/lmu/ifi/dbs/elki/converter/ArffSparseInstanceToSparseBitVector.html">de.lmu.ifi.dbs.elki.converter.ArffSparseInstanceToSparseBitVector</a>
</dt>
<dd>
<dl>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.in</tt>
</dt>
<dd>The name of the arff-file to convert.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>the txt-file to write the converted arff-file in.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.converter.Txt2Arff"/>
<a href="de/lmu/ifi/dbs/elki/converter/Txt2Arff.html">de.lmu.ifi.dbs.elki.converter.Txt2Arff</a>
</dt>
<dd>
<dl>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.in</tt>
</dt>
<dd>The name of the txt-file to convert.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>the arff-file to write the converted txt-file in.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.data.synthetic.ArbitraryCorrelationGenerator"/>
<a href="de/lmu/ifi/dbs/elki/data/synthetic/ArbitraryCorrelationGenerator.html">de.lmu.ifi.dbs.elki.data.synthetic.ArbitraryCorrelationGenerator</a>
</dt>
<dd>
<dl>
<dt>
<tt>-acg.basis</tt>
</dt>
<dd>a list of basis vectors of the correlation hyperplane, where c denotes the correlation dimensionality and d the dimensionality of the feature space. Each basis vector is separated by :, the coordinates within the basis vectors are separated by a comma. If no basis is specified, the basis vectors are generated randomly.</dd>
<dt>
<tt>-acg.gaussian</tt>
</dt>
<dd>flag to indicate gaussian distribution, default is an equal distribution.</dd>
<dt>
<tt>-acg.point</tt>
</dt>
<dd>a comma separated list of the coordinates of the model point, default is the centroid of the defined feature space.</dd>
<dt>
<tt>-apcg.corrdim</tt>
</dt>
<dd>the correlation dimensionality of the correlation hyperplane.<br/>Constraint: apcg.corrdim &gt; 0.</dd>
<dt>
<tt>-apcg.dep</tt>
</dt>
<dd>a vector specifying the dependent and independent variables of the correlation hyperplane, where d denotes the dimensionality of the feature space. p_i = 0 specifies an independent variable, any other value of p_i specifies the value of the dependent variable. The number of zero values has to correspond with the specified correlation dimensionality. The values of the dependent variables have to correspond with the specified main and max values. If no vector is specified, the first dataDim - corrDim variables are the dependent variables (the values will be randomized), the last corrDim variables are the independent variables.</dd>
<dt>
<tt>-apcg.dim</tt>
</dt>
<dd>the dimensionality of the feature space.<br/>Constraint: apcg.dim &gt; 0.</dd>
<dt>
<tt>-apcg.jitter</tt>
</dt>
<dd>maximum percentage [0..1] of jitter in each dimension, default is 0.0.<br/>Default: 0.0.<br/>Constraint: apcg.jitter in [0.0, 1.0].</dd>
<dt>
<tt>-apcg.label</tt>
</dt>
<dd>a label specifiying the correlation hyperplane, default is no label.<br/>Default: .</dd>
<dt>
<tt>-apcg.maxima</tt>
</dt>
<dd>a comma separated list of the coordinates of the maximum value in each dimension, default is 1.0 in each dimension</dd>
<dt>
<tt>-apcg.minima</tt>
</dt>
<dd>a comma separated list of the coordinates of the minimum value in each dimension, default is 0.0 in each dimension</dd>
<dt>
<tt>-apcg.number</tt>
</dt>
<dd>the (positive) number of points in the correlation hyperplane.<br/>Constraint: apcg.number &gt; 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>the file to write the generated correlation hyperplane in, if the file already exists, the generated points will be appended to this file.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.data.synthetic.AxesParallelCorrelationGenerator"/>
<a href="de/lmu/ifi/dbs/elki/data/synthetic/AxesParallelCorrelationGenerator.html">de.lmu.ifi.dbs.elki.data.synthetic.AxesParallelCorrelationGenerator</a>
</dt>
<dd>
<dl>
<dt>
<tt>-apcg.corrdim</tt>
</dt>
<dd>the correlation dimensionality of the correlation hyperplane.<br/>Constraint: apcg.corrdim &gt; 0.</dd>
<dt>
<tt>-apcg.dep</tt>
</dt>
<dd>a vector specifying the dependent and independent variables of the correlation hyperplane, where d denotes the dimensionality of the feature space. p_i = 0 specifies an independent variable, any other value of p_i specifies the value of the dependent variable. The number of zero values has to correspond with the specified correlation dimensionality. The values of the dependent variables have to correspond with the specified main and max values. If no vector is specified, the first dataDim - corrDim variables are the dependent variables (the values will be randomized), the last corrDim variables are the independent variables.</dd>
<dt>
<tt>-apcg.dim</tt>
</dt>
<dd>the dimensionality of the feature space.<br/>Constraint: apcg.dim &gt; 0.</dd>
<dt>
<tt>-apcg.jitter</tt>
</dt>
<dd>maximum percentage [0..1] of jitter in each dimension, default is 0.0.<br/>Default: 0.0.<br/>Constraint: apcg.jitter in [0.0, 1.0].</dd>
<dt>
<tt>-apcg.label</tt>
</dt>
<dd>a label specifiying the correlation hyperplane, default is no label.<br/>Default: .</dd>
<dt>
<tt>-apcg.maxima</tt>
</dt>
<dd>a comma separated list of the coordinates of the maximum value in each dimension, default is 1.0 in each dimension</dd>
<dt>
<tt>-apcg.minima</tt>
</dt>
<dd>a comma separated list of the coordinates of the minimum value in each dimension, default is 0.0 in each dimension</dd>
<dt>
<tt>-apcg.number</tt>
</dt>
<dd>the (positive) number of points in the correlation hyperplane.<br/>Constraint: apcg.number &gt; 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>the file to write the generated correlation hyperplane in, if the file already exists, the generated points will be appended to this file.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.data.synthetic.bymodel.GeneratorXMLSpec"/>
<a href="de/lmu/ifi/dbs/elki/data/synthetic/bymodel/GeneratorXMLSpec.html">de.lmu.ifi.dbs.elki.data.synthetic.bymodel.GeneratorXMLSpec</a>
</dt>
<dd>
<dl>
<dt>
<tt>-bymodel.randomseed</tt>
</dt>
<dd>The random generator seed.</dd>
<dt>
<tt>-bymodel.sizescale</tt>
</dt>
<dd>Factor for scaling the specified cluster sizes.<br/>Default: 1.0.</dd>
<dt>
<tt>-bymodel.spec</tt>
</dt>
<dd>The generator specification file.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>the file to write the generated data set into, if the file already exists, the generated points will be appended to this file.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.database.MetricalIndexDatabase"/>
<a href="de/lmu/ifi/dbs/elki/database/MetricalIndexDatabase.html">de.lmu.ifi.dbs.elki.database.MetricalIndexDatabase</a>
</dt>
<dd>
<dl>
<dt>
<tt>-metricalindexdb.index</tt>
</dt>
<dd>Metrical index class to use.<br/>Extending de.lmu.ifi.dbs.elki.index.tree.metrical.MetricalIndex<br/>Known classes (default package de.lmu.ifi.dbs.elki.index.tree.metrical.):<br/>-&gt; mtreevariants.mtree.MTree<br/>-&gt; mtreevariants.mktrees.mkcop.MkCoPTree<br/>-&gt; mtreevariants.mktrees.mkmax.MkMaxTree<br/>-&gt; mtreevariants.mktrees.mktab.MkTabTree</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.database.SpatialIndexDatabase"/>
<a href="de/lmu/ifi/dbs/elki/database/SpatialIndexDatabase.html">de.lmu.ifi.dbs.elki.database.SpatialIndexDatabase</a>
</dt>
<dd>
<dl>
<dt>
<tt>-spatialindexdb.index</tt>
</dt>
<dd>Spatial index class to use.<br/>Extending de.lmu.ifi.dbs.elki.index.tree.spatial.SpatialIndex<br/>Known classes (default package de.lmu.ifi.dbs.elki.index.tree.spatial.):<br/>-&gt; rstarvariants.deliclu.DeLiCluTree<br/>-&gt; rstarvariants.rstar.RStarTree<br/>-&gt; rstarvariants.rdknn.RdKNNTree</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.database.connection.FileBasedDatabaseConnection"/>
<a href="de/lmu/ifi/dbs/elki/database/connection/FileBasedDatabaseConnection.html">de.lmu.ifi.dbs.elki.database.connection.FileBasedDatabaseConnection</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.classLabelClass</tt>
</dt>
<dd>Class label class to use.<br/>Extending de.lmu.ifi.dbs.elki.data.ClassLabel<br/>Known classes (default package de.lmu.ifi.dbs.elki.data.):<br/>-&gt; SimpleClassLabel<br/>-&gt; HierarchicalClassLabel<br/>Default: de.lmu.ifi.dbs.elki.data.SimpleClassLabel.</dd>
<dt>
<tt>-dbc.classLabelIndex</tt>
</dt>
<dd>The index of the label to be used as class label.<br/>Constraint: dbc.classLabelIndex &gt;= 0.</dd>
<dt>
<tt>-dbc.database</tt>
</dt>
<dd>Database class to be provided by the parse method.<br/>Implementing de.lmu.ifi.dbs.elki.database.Database<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.):<br/>-&gt; MetricalIndexDatabase<br/>-&gt; SequentialDatabase<br/>-&gt; SpatialIndexDatabase<br/>Default: de.lmu.ifi.dbs.elki.database.SequentialDatabase.</dd>
<dt>
<tt>-dbc.externalIDIndex</tt>
</dt>
<dd>The index of the label to be used as an external id.<br/>Constraint: dbc.externalIDIndex &gt;= 0.</dd>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-dbc.parser</tt>
</dt>
<dd>Parser to provide the database.<br/>Implementing de.lmu.ifi.dbs.elki.parser.Parser<br/>Known classes (default package de.lmu.ifi.dbs.elki.parser.):<br/>-&gt; BitVectorLabelParser<br/>-&gt; NumberDistanceParser<br/>-&gt; ParameterizationFunctionLabelParser<br/>-&gt; DoubleVectorLabelParser<br/>-&gt; FloatVectorLabelParser<br/>-&gt; DoubleVectorLabelTransposingParser<br/>-&gt; SparseBitVectorLabelParser<br/>Default: de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.database.connection.InputStreamDatabaseConnection"/>
<a href="de/lmu/ifi/dbs/elki/database/connection/InputStreamDatabaseConnection.html">de.lmu.ifi.dbs.elki.database.connection.InputStreamDatabaseConnection</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.classLabelClass</tt>
</dt>
<dd>Class label class to use.<br/>Extending de.lmu.ifi.dbs.elki.data.ClassLabel<br/>Known classes (default package de.lmu.ifi.dbs.elki.data.):<br/>-&gt; SimpleClassLabel<br/>-&gt; HierarchicalClassLabel<br/>Default: de.lmu.ifi.dbs.elki.data.SimpleClassLabel.</dd>
<dt>
<tt>-dbc.classLabelIndex</tt>
</dt>
<dd>The index of the label to be used as class label.<br/>Constraint: dbc.classLabelIndex &gt;= 0.</dd>
<dt>
<tt>-dbc.database</tt>
</dt>
<dd>Database class to be provided by the parse method.<br/>Implementing de.lmu.ifi.dbs.elki.database.Database<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.):<br/>-&gt; MetricalIndexDatabase<br/>-&gt; SequentialDatabase<br/>-&gt; SpatialIndexDatabase<br/>Default: de.lmu.ifi.dbs.elki.database.SequentialDatabase.</dd>
<dt>
<tt>-dbc.externalIDIndex</tt>
</dt>
<dd>The index of the label to be used as an external id.<br/>Constraint: dbc.externalIDIndex &gt;= 0.</dd>
<dt>
<tt>-dbc.parser</tt>
</dt>
<dd>Parser to provide the database.<br/>Implementing de.lmu.ifi.dbs.elki.parser.Parser<br/>Known classes (default package de.lmu.ifi.dbs.elki.parser.):<br/>-&gt; BitVectorLabelParser<br/>-&gt; NumberDistanceParser<br/>-&gt; ParameterizationFunctionLabelParser<br/>-&gt; DoubleVectorLabelParser<br/>-&gt; FloatVectorLabelParser<br/>-&gt; DoubleVectorLabelTransposingParser<br/>-&gt; SparseBitVectorLabelParser<br/>Default: de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.database.connection.MultipleFileBasedDatabaseConnection"/>
<a href="de/lmu/ifi/dbs/elki/database/connection/MultipleFileBasedDatabaseConnection.html">de.lmu.ifi.dbs.elki.database.connection.MultipleFileBasedDatabaseConnection</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.classLabelClass</tt>
</dt>
<dd>Class label class to use.<br/>Extending de.lmu.ifi.dbs.elki.data.ClassLabel<br/>Known classes (default package de.lmu.ifi.dbs.elki.data.):<br/>-&gt; SimpleClassLabel<br/>-&gt; HierarchicalClassLabel<br/>Default: de.lmu.ifi.dbs.elki.data.SimpleClassLabel.</dd>
<dt>
<tt>-dbc.classLabelIndex</tt>
</dt>
<dd>The index of the label to be used as class label.<br/>Constraint: dbc.classLabelIndex &gt;= 0.</dd>
<dt>
<tt>-dbc.database</tt>
</dt>
<dd>Database class to be provided by the parse method.<br/>Implementing de.lmu.ifi.dbs.elki.database.Database<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.):<br/>-&gt; MetricalIndexDatabase<br/>-&gt; SequentialDatabase<br/>-&gt; SpatialIndexDatabase<br/>Default: de.lmu.ifi.dbs.elki.database.SequentialDatabase.</dd>
<dt>
<tt>-dbc.externalIDIndex</tt>
</dt>
<dd>The index of the label to be used as an external id.<br/>Constraint: dbc.externalIDIndex &gt;= 0.</dd>
<dt>
<tt>-multipledbc.in</tt>
</dt>
<dd>A comma separated list of the names of the input files to be parsed.</dd>
<dt>
<tt>-multipledbc.parsers</tt>
</dt>
<dd>Comma separated list of classnames specifying the parsers to provide a database. If this parameter is not set, de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser is used as parser for all input files.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.DiSHDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/DiSHDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.DiSHDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-distancefunction.epsilon</tt>
</dt>
<dd>The maximum distance between two vectors with equal preference vectors before considering them as parallel.<br/>Default: 0.0010.<br/>Constraint: distancefunction.epsilon &gt;= 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.DimensionSelectingDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/DimensionSelectingDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.DimensionSelectingDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dim</tt>
</dt>
<dd>an integer between 1 and the dimensionality of the feature space 1 specifying the dimension to be considered for distance computation.<br/>Constraint: dim &gt;= 1.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.DimensionsSelectingEuclideanDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/DimensionsSelectingEuclideanDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.DimensionsSelectingEuclideanDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-distance.dims</tt>
</dt>
<dd>a comma separated array of integer values, where 1 &lt;= d_i &lt;= the dimensionality of the feature space specifying the dimensions to be considered for distance computation. If this parameter is not set, no dimensions will be considered, i.e. the distance between two objects is always 0.<br/>Constraint: all elements of distance.dims &lt; 1.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.ERiCDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/ERiCDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.ERiCDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-ericdf.delta</tt>
</dt>
<dd>Threshold for approximate linear dependency: the strong eigenvectors of q are approximately linear dependent from the strong eigenvectors p if the following condition holds for all stroneg eigenvectors q_i of q (lambda_q &lt; lambda_p): q_i' * M^check_p * q_i &lt;= delta^2.<br/>Default: 0.1.<br/>Constraint: ericdf.delta &gt;= 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.FileBasedDoubleDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/FileBasedDoubleDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.FileBasedDoubleDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-distance.matrix</tt>
</dt>
<dd>The name of the file containing the distance matrix.</dd>
<dt>
<tt>-distance.parser</tt>
</dt>
<dd>Parser used to load the distance matrix.<br/>Implementing de.lmu.ifi.dbs.elki.parser.DistanceParserDefault: de.lmu.ifi.dbs.elki.parser.NumberDistanceParser.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.FileBasedFloatDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/FileBasedFloatDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.FileBasedFloatDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-distance.matrix</tt>
</dt>
<dd>The name of the file containing the distance matrix.</dd>
<dt>
<tt>-distance.parser</tt>
</dt>
<dd>Parser used to load the distance matrix.<br/>Implementing de.lmu.ifi.dbs.elki.parser.DistanceParserDefault: de.lmu.ifi.dbs.elki.parser.NumberDistanceParser.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.HiSCDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/HiSCDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.HiSCDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-distancefunction.epsilon</tt>
</dt>
<dd>The maximum distance between two vectors with equal preference vectors before considering them as parallel.<br/>Default: 0.0010.<br/>Constraint: distancefunction.epsilon &gt;= 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.KernelBasedLocallyWeightedDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/KernelBasedLocallyWeightedDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.KernelBasedLocallyWeightedDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-kernel</tt>
</dt>
<dd>the kernel function which is used to compute the similarity.Default: de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.LinearKernelFunction<br/>Implementing de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.KernelFunctionDefault: de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.LinearKernelFunction.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.LPNormDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/LPNormDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.LPNormDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-lpnorm.p</tt>
</dt>
<dd>the degree of the L-P-Norm (positive number)<br/>Constraint: lpnorm.p &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.PCABasedCorrelationDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/PCABasedCorrelationDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.PCABasedCorrelationDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-pcabasedcorrelationdf.delta</tt>
</dt>
<dd>Threshold of a distance between a vector q and a given space that indicates that q adds a new dimension to the space.<br/>Default: 0.25.<br/>Constraint: pcabasedcorrelationdf.delta &gt;= 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.RepresentationSelectingDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/RepresentationSelectingDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.RepresentationSelectingDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-distancefunctions</tt>
</dt>
<dd>A comma separated list of the distance functions to determine the distance between objects within one representation.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.SimilarityAdapterArccos"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/SimilarityAdapterArccos.html">de.lmu.ifi.dbs.elki.distance.distancefunction.SimilarityAdapterArccos</a>
</dt>
<dd>
<dl>
<dt>
<tt>-adapter.similarityfunction</tt>
</dt>
<dd>Similarity function to derive the distance between database objects from.<br/>Implementing de.lmu.ifi.dbs.elki.distance.similarityfunction.NormalizedSimilarityFunctionDefault: de.lmu.ifi.dbs.elki.distance.similarityfunction.FractionalSharedNearestNeighborSimilarityFunction.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.SimilarityAdapterLinear"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/SimilarityAdapterLinear.html">de.lmu.ifi.dbs.elki.distance.distancefunction.SimilarityAdapterLinear</a>
</dt>
<dd>
<dl>
<dt>
<tt>-adapter.similarityfunction</tt>
</dt>
<dd>Similarity function to derive the distance between database objects from.<br/>Implementing de.lmu.ifi.dbs.elki.distance.similarityfunction.NormalizedSimilarityFunctionDefault: de.lmu.ifi.dbs.elki.distance.similarityfunction.FractionalSharedNearestNeighborSimilarityFunction.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.SimilarityAdapterLn"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/SimilarityAdapterLn.html">de.lmu.ifi.dbs.elki.distance.distancefunction.SimilarityAdapterLn</a>
</dt>
<dd>
<dl>
<dt>
<tt>-adapter.similarityfunction</tt>
</dt>
<dd>Similarity function to derive the distance between database objects from.<br/>Implementing de.lmu.ifi.dbs.elki.distance.similarityfunction.NormalizedSimilarityFunctionDefault: de.lmu.ifi.dbs.elki.distance.similarityfunction.FractionalSharedNearestNeighborSimilarityFunction.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.timeseries.DTWDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/timeseries/DTWDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.timeseries.DTWDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-edit.bandSize</tt>
</dt>
<dd>the band size for Edit Distance alignment (positive double value, 0 &lt;= bandSize &lt;= 1)<br/>Default: 0.1.<br/>Constraint: edit.bandSize in [0, 1].</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.timeseries.EDRDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/timeseries/EDRDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.timeseries.EDRDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-edit.bandSize</tt>
</dt>
<dd>the band size for Edit Distance alignment (positive double value, 0 &lt;= bandSize &lt;= 1)<br/>Default: 0.1.<br/>Constraint: edit.bandSize in [0, 1].</dd>
<dt>
<tt>-edr.delta</tt>
</dt>
<dd>the delta parameter (similarity threshold) for EDR (positive number)<br/>Default: 1.0.<br/>Constraint: edr.delta &gt;= 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.timeseries.ERPDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/timeseries/ERPDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.timeseries.ERPDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-edit.bandSize</tt>
</dt>
<dd>the band size for Edit Distance alignment (positive double value, 0 &lt;= bandSize &lt;= 1)<br/>Default: 0.1.<br/>Constraint: edit.bandSize in [0, 1].</dd>
<dt>
<tt>-erp.g</tt>
</dt>
<dd>the g parameter ERP (positive number)<br/>Default: 0.0.<br/>Constraint: erp.g &gt;= 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.distancefunction.timeseries.LCSSDistanceFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/distancefunction/timeseries/LCSSDistanceFunction.html">de.lmu.ifi.dbs.elki.distance.distancefunction.timeseries.LCSSDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-lcss.pDelta</tt>
</dt>
<dd>the allowed deviation in x direction for LCSS alignment (positive double value, 0 &lt;= pDelta &lt;= 1)<br/>Default: 0.1.<br/>Constraint: lcss.pDelta in [0, 1].</dd>
<dt>
<tt>-lcss.pEpsilon</tt>
</dt>
<dd>the allowed deviation in y directionfor LCSS alignment (positive double value, 0 &lt;= pEpsilon &lt;= 1)<br/>Default: 0.05.<br/>Constraint: lcss.pEpsilon in [0, 1].</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.FooKernelFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/similarityfunction/kernel/FooKernelFunction.html">de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.FooKernelFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-fookernel.max_degree</tt>
</dt>
<dd>The max degree of theFooKernelFunction. Default: 2<br/>Default: 2.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.PolynomialKernelFunction"/>
<a href="de/lmu/ifi/dbs/elki/distance/similarityfunction/kernel/PolynomialKernelFunction.html">de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.PolynomialKernelFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-kernel.degree</tt>
</dt>
<dd>The degree of the polynomial kernel function. Default: 2.0<br/>Default: 2.0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.evaluation.holdout.DisjointCrossValidation"/>
<a href="de/lmu/ifi/dbs/elki/evaluation/holdout/DisjointCrossValidation.html">de.lmu.ifi.dbs.elki.evaluation.holdout.DisjointCrossValidation</a>
</dt>
<dd>
<dl>
<dt>
<tt>-nfold</tt>
</dt>
<dd>positive number of folds for cross-validation<br/>Default: 10.<br/>Constraint: nfold &gt; 0.</dd>
<dt>
<tt>-seed</tt>
</dt>
<dd>seed for randomized holdout (&gt;0)<br/>Default: 1.<br/>Constraint: seed &gt; 0.0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.evaluation.holdout.ProvidedTestSet"/>
<a href="de/lmu/ifi/dbs/elki/evaluation/holdout/ProvidedTestSet.html">de.lmu.ifi.dbs.elki.evaluation.holdout.ProvidedTestSet</a>
</dt>
<dd>
<dl>
<dt>
<tt>-testdbc</tt>
</dt>
<dd>Database connection to testset database.<br/>Implementing de.lmu.ifi.dbs.elki.database.connection.DatabaseConnection<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.connection.):<br/>-&gt; FileBasedDatabaseConnection<br/>-&gt; InputStreamDatabaseConnection<br/>-&gt; MultipleFileBasedDatabaseConnection<br/>Default: de.lmu.ifi.dbs.elki.database.connection.FileBasedDatabaseConnection.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.evaluation.holdout.RandomizedCrossValidation"/>
<a href="de/lmu/ifi/dbs/elki/evaluation/holdout/RandomizedCrossValidation.html">de.lmu.ifi.dbs.elki.evaluation.holdout.RandomizedCrossValidation</a>
</dt>
<dd>
<dl>
<dt>
<tt>-nfold</tt>
</dt>
<dd>positive number of folds for cross-validation<br/>Default: 10.<br/>Constraint: nfold &gt; 0.</dd>
<dt>
<tt>-seed</tt>
</dt>
<dd>seed for randomized holdout (&gt;0)<br/>Default: 1.<br/>Constraint: seed &gt; 0.0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.evaluation.holdout.StratifiedCrossValidation"/>
<a href="de/lmu/ifi/dbs/elki/evaluation/holdout/StratifiedCrossValidation.html">de.lmu.ifi.dbs.elki.evaluation.holdout.StratifiedCrossValidation</a>
</dt>
<dd>
<dl>
<dt>
<tt>-nfold</tt>
</dt>
<dd>positive number of folds for cross-validation<br/>Default: 10.<br/>Constraint: nfold &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.evaluation.procedure.ClassifierEvaluationProcedure"/>
<a href="de/lmu/ifi/dbs/elki/evaluation/procedure/ClassifierEvaluationProcedure.html">de.lmu.ifi.dbs.elki.evaluation.procedure.ClassifierEvaluationProcedure</a>
</dt>
<dd>
<dl>
<dt>
<tt>-classifier.holdout</tt>
</dt>
<dd>Holdout class used in evaluation.<br/>Implementing de.lmu.ifi.dbs.elki.evaluation.holdout.Holdout<br/>Known classes (default package de.lmu.ifi.dbs.elki.evaluation.holdout.):<br/>-&gt; DisjointCrossValidation<br/>-&gt; LeaveOneOut<br/>-&gt; ProvidedTestSet<br/>-&gt; RandomizedCrossValidation<br/>-&gt; StratifiedCrossValidation<br/>Default: de.lmu.ifi.dbs.elki.evaluation.holdout.StratifiedCrossValidation.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mktrees.mkapp.MkAppTree"/>
<a href="de/lmu/ifi/dbs/elki/index/tree/metrical/mtreevariants/mktrees/mkapp/MkAppTree.html">de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mktrees.mkapp.MkAppTree</a>
</dt>
<dd>
<dl>
<dt>
<tt>-mkapp.k</tt>
</dt>
<dd>positive integer specifying the maximal number k of reversek nearest neighbors to be supported.<br/>Constraint: mkapp.k &gt; 0.</dd>
<dt>
<tt>-mkapp.nolog</tt>
</dt>
<dd>Flag to indicate that the approximation is done in the ''normal'' space instead of the log-log space (which is default).</dd>
<dt>
<tt>-mkapp.p</tt>
</dt>
<dd>positive integer specifying the order of the polynomial approximation.<br/>Constraint: mkapp.p &gt; 0.</dd>
<dt>
<tt>-mtree.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mktrees.mkcop.MkCoPTree"/>
<a href="de/lmu/ifi/dbs/elki/index/tree/metrical/mtreevariants/mktrees/mkcop/MkCoPTree.html">de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mktrees.mkcop.MkCoPTree</a>
</dt>
<dd>
<dl>
<dt>
<tt>-mkcop.k</tt>
</dt>
<dd>positive integer specifying the maximal number k of reversek nearest neighbors to be supported.<br/>Constraint: mkcop.k &gt; 0.</dd>
<dt>
<tt>-mtree.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mktrees.mkmax.MkMaxTree"/>
<a href="de/lmu/ifi/dbs/elki/index/tree/metrical/mtreevariants/mktrees/mkmax/MkMaxTree.html">de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mktrees.mkmax.MkMaxTree</a>
</dt>
<dd>
<dl>
<dt>
<tt>-mktree.kmax</tt>
</dt>
<dd>Specifies the maximal number k of reverse k nearest neighbors to be supported.<br/>Constraint: mktree.kmax &gt; 0.</dd>
<dt>
<tt>-mtree.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mktrees.mktab.MkTabTree"/>
<a href="de/lmu/ifi/dbs/elki/index/tree/metrical/mtreevariants/mktrees/mktab/MkTabTree.html">de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mktrees.mktab.MkTabTree</a>
</dt>
<dd>
<dl>
<dt>
<tt>-mktree.kmax</tt>
</dt>
<dd>Specifies the maximal number k of reverse k nearest neighbors to be supported.<br/>Constraint: mktree.kmax &gt; 0.</dd>
<dt>
<tt>-mtree.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mtree.MTree"/>
<a href="de/lmu/ifi/dbs/elki/index/tree/metrical/mtreevariants/mtree/MTree.html">de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mtree.MTree</a>
</dt>
<dd>
<dl>
<dt>
<tt>-mtree.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.index.tree.spatial.rstarvariants.deliclu.DeLiCluTree"/>
<a href="de/lmu/ifi/dbs/elki/index/tree/spatial/rstarvariants/deliclu/DeLiCluTree.html">de.lmu.ifi.dbs.elki.index.tree.spatial.rstarvariants.deliclu.DeLiCluTree</a>
</dt>
<dd>
<dl>
<dt>
<tt>-spatial.bulk</tt>
</dt>
<dd>flag to specify bulk load (default is no bulk load)</dd>
<dt>
<tt>-spatial.bulkstrategy</tt>
</dt>
<dd>the strategy for bulk load, available strategies are: [MAX_EXTENSION| ZCURVE](default is ZCURVE)<br/>Default: ZCURVE.<br/>Constraint: spatial.bulkstrategy in [MAX_EXTENSION, ZCURVE].</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.index.tree.spatial.rstarvariants.flat.FlatRStarTree"/>
<a href="de/lmu/ifi/dbs/elki/index/tree/spatial/rstarvariants/flat/FlatRStarTree.html">de.lmu.ifi.dbs.elki.index.tree.spatial.rstarvariants.flat.FlatRStarTree</a>
</dt>
<dd>
<dl>
<dt>
<tt>-spatial.bulk</tt>
</dt>
<dd>flag to specify bulk load (default is no bulk load)</dd>
<dt>
<tt>-spatial.bulkstrategy</tt>
</dt>
<dd>the strategy for bulk load, available strategies are: [MAX_EXTENSION| ZCURVE](default is ZCURVE)<br/>Default: ZCURVE.<br/>Constraint: spatial.bulkstrategy in [MAX_EXTENSION, ZCURVE].</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.index.tree.spatial.rstarvariants.rdknn.RdKNNTree"/>
<a href="de/lmu/ifi/dbs/elki/index/tree/spatial/rstarvariants/rdknn/RdKNNTree.html">de.lmu.ifi.dbs.elki.index.tree.spatial.rstarvariants.rdknn.RdKNNTree</a>
</dt>
<dd>
<dl>
<dt>
<tt>-rdknn.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.index.tree.spatial.SpatialDistanceFunctionDefault: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-rdknn.k</tt>
</dt>
<dd>positive integer specifying the maximal number k of reverse k nearest neighbors to be supported.<br/>Constraint: rdknn.k &gt; 0.</dd>
<dt>
<tt>-spatial.bulk</tt>
</dt>
<dd>flag to specify bulk load (default is no bulk load)</dd>
<dt>
<tt>-spatial.bulkstrategy</tt>
</dt>
<dd>the strategy for bulk load, available strategies are: [MAX_EXTENSION| ZCURVE](default is ZCURVE)<br/>Default: ZCURVE.<br/>Constraint: spatial.bulkstrategy in [MAX_EXTENSION, ZCURVE].</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.index.tree.spatial.rstarvariants.rstar.RStarTree"/>
<a href="de/lmu/ifi/dbs/elki/index/tree/spatial/rstarvariants/rstar/RStarTree.html">de.lmu.ifi.dbs.elki.index.tree.spatial.rstarvariants.rstar.RStarTree</a>
</dt>
<dd>
<dl>
<dt>
<tt>-spatial.bulk</tt>
</dt>
<dd>flag to specify bulk load (default is no bulk load)</dd>
<dt>
<tt>-spatial.bulkstrategy</tt>
</dt>
<dd>the strategy for bulk load, available strategies are: [MAX_EXTENSION| ZCURVE](default is ZCURVE)<br/>Default: ZCURVE.<br/>Constraint: spatial.bulkstrategy in [MAX_EXTENSION, ZCURVE].</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CompositeEigenPairFilter"/>
<a href="de/lmu/ifi/dbs/elki/math/linearalgebra/pca/CompositeEigenPairFilter.html">de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CompositeEigenPairFilter</a>
</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.composite.list</tt>
</dt>
<dd>A comma separated list of the class names of the filters to be used. The specified filters will be applied sequentially in the given order.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.math.linearalgebra.pca.FirstNEigenPairFilter"/>
<a href="de/lmu/ifi/dbs/elki/math/linearalgebra/pca/FirstNEigenPairFilter.html">de.lmu.ifi.dbs.elki.math.linearalgebra.pca.FirstNEigenPairFilter</a>
</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.n</tt>
</dt>
<dd>The number of strong eigenvectors: n eigenvectors with the n highesteigenvalues are marked as strong eigenvectors.<br/>Constraint: pca.filter.n &gt;= 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.math.linearalgebra.pca.LimitEigenPairFilter"/>
<a href="de/lmu/ifi/dbs/elki/math/linearalgebra/pca/LimitEigenPairFilter.html">de.lmu.ifi.dbs.elki.math.linearalgebra.pca.LimitEigenPairFilter</a>
</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.absolute</tt>
</dt>
<dd>Flag to mark delta as an absolute value.</dd>
<dt>
<tt>-pca.filter.delta</tt>
</dt>
<dd>The threshold for strong Eigenvalues. If not otherwise specified, delta is a relative value w.r.t. the (absolute) highest Eigenvalues and has to be a double between 0 and 1. To mark delta as an absolute value, use the option -pca.filter.absolute.<br/>Default: 0.01.<br/>Constraint: pca.filter.delta &gt;= 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PCAFilteredRunner"/>
<a href="de/lmu/ifi/dbs/elki/math/linearalgebra/pca/PCAFilteredRunner.html">de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PCAFilteredRunner</a>
</dt>
<dd>
<dl>
<dt>
<tt>-localpca.big</tt>
</dt>
<dd>A constant big value to reset high eigenvalues.<br/>Default: 1.0.<br/>Constraint: localpca.big &gt; 0.</dd>
<dt>
<tt>-localpca.small</tt>
</dt>
<dd>A constant small value to reset low eigenvalues.<br/>Default: 0.0.<br/>Constraint: localpca.small &gt;= 0.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PCARunner"/>
<a href="de/lmu/ifi/dbs/elki/math/linearalgebra/pca/PCARunner.html">de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PCARunner</a>
</dt>
<dd>
<dl>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter"/>
<a href="de/lmu/ifi/dbs/elki/math/linearalgebra/pca/PercentageEigenPairFilter.html">de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter</a>
</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.alpha</tt>
</dt>
<dd>The share (0.0 to 1.0) of variance that needs to be explained by the 'strong' eigenvectors.The filter class will choose the number of strong eigenvectors by this share.<br/>Default: 0.85.<br/>Constraint: pca.filter.alpha in (0.0, 1.0).</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.math.linearalgebra.pca.ProgressiveEigenPairFilter"/>
<a href="de/lmu/ifi/dbs/elki/math/linearalgebra/pca/ProgressiveEigenPairFilter.html">de.lmu.ifi.dbs.elki.math.linearalgebra.pca.ProgressiveEigenPairFilter</a>
</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.progressivealpha</tt>
</dt>
<dd>The share (0.0 to 1.0) of variance that needs to be explained by the 'strong' eigenvectors.The filter class will choose the number of strong eigenvectors by this share.<br/>Default: 0.5.<br/>Constraint: pca.filter.progressivealpha in (0.0, 1.0).</dd>
<dt>
<tt>-pca.filter.weakalpha</tt>
</dt>
<dd>The minimum strength of the statistically expected variance (1/n) share an eigenvector needs to have to be considered 'strong'.<br/>Default: 0.95.<br/>Constraint: pca.filter.weakalpha &gt;= 0.0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.math.linearalgebra.pca.RelativeEigenPairFilter"/>
<a href="de/lmu/ifi/dbs/elki/math/linearalgebra/pca/RelativeEigenPairFilter.html">de.lmu.ifi.dbs.elki.math.linearalgebra.pca.RelativeEigenPairFilter</a>
</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.relativealpha</tt>
</dt>
<dd>The sensitivity niveau for weak eigenvectors: An eigenvector which is at less than the given share of the statistical average variance is considered weak.<br/>Default: 1.1.<br/>Constraint: pca.filter.relativealpha &gt;= 0.0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.math.linearalgebra.pca.SignificantEigenPairFilter"/>
<a href="de/lmu/ifi/dbs/elki/math/linearalgebra/pca/SignificantEigenPairFilter.html">de.lmu.ifi.dbs.elki.math.linearalgebra.pca.SignificantEigenPairFilter</a>
</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.weakalpha</tt>
</dt>
<dd>The minimum strength of the statistically expected variance (1/n) share an eigenvector needs to have to be considered 'strong'.<br/>Default: 0.0.<br/>Constraint: pca.filter.weakalpha &gt;= 0.0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.math.linearalgebra.pca.WeakEigenPairFilter"/>
<a href="de/lmu/ifi/dbs/elki/math/linearalgebra/pca/WeakEigenPairFilter.html">de.lmu.ifi.dbs.elki.math.linearalgebra.pca.WeakEigenPairFilter</a>
</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.weakalpha</tt>
</dt>
<dd>The minimum strength of the statistically expected variance (1/n) share an eigenvector needs to have to be considered 'strong'.<br/>Default: 0.95.<br/>Constraint: pca.filter.weakalpha &gt;= 0.0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.math.linearalgebra.pca.WeightedCovarianceMatrixBuilder"/>
<a href="de/lmu/ifi/dbs/elki/math/linearalgebra/pca/WeightedCovarianceMatrixBuilder.html">de.lmu.ifi.dbs.elki.math.linearalgebra.pca.WeightedCovarianceMatrixBuilder</a>
</dt>
<dd>
<dl>
<dt>
<tt>-pca.weight</tt>
</dt>
<dd>Weight function to use in weighted PCA.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.weightfunctions.WeightFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.weightfunctions.):<br/>-&gt; ConstantWeight<br/>-&gt; ErfcStddevWeight<br/>-&gt; ErfcWeight<br/>-&gt; ExponentialStddevWeight<br/>-&gt; ExponentialWeight<br/>-&gt; GaussStddevWeight<br/>-&gt; GaussWeight<br/>-&gt; InverseLinearWeight<br/>-&gt; InverseProportionalStddevWeight<br/>-&gt; InverseProportionalWeight<br/>-&gt; LinearWeight<br/>-&gt; QuadraticStddevWeight<br/>-&gt; QuadraticWeight<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.weightfunctions.ConstantWeight.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.normalization.AttributeWiseRealVectorNormalization"/>
<a href="de/lmu/ifi/dbs/elki/normalization/AttributeWiseRealVectorNormalization.html">de.lmu.ifi.dbs.elki.normalization.AttributeWiseRealVectorNormalization</a>
</dt>
<dd>
<dl>
<dt>
<tt>-normalize.max</tt>
</dt>
<dd>a comma separated concatenation of the maximum values in each dimension that are mapped to 1 If no value is specified, the maximum value of the attribute range in this dimension will be taken.</dd>
<dt>
<tt>-normalize.min</tt>
</dt>
<dd>a comma separated concatenation of the minimum values in each dimension that are mapped to 0. If no value is specified, the minimum value of the attribute range in this dimension will be taken.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.normalization.MultiRepresentedObjectNormalization"/>
<a href="de/lmu/ifi/dbs/elki/normalization/MultiRepresentedObjectNormalization.html">de.lmu.ifi.dbs.elki.normalization.MultiRepresentedObjectNormalization</a>
</dt>
<dd>
<dl>
<dt>
<tt>-normalizations</tt>
</dt>
<dd>A comma separated list of normalizations for each representation. If in one representation no normalization is desired, please use the class 'de.lmu.ifi.dbs.elki.normalization.DummyNormalization' in the list.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.parser.ArffFileParser"/>
<a href="de/lmu/ifi/dbs/elki/parser/ArffFileParser.html">de.lmu.ifi.dbs.elki.parser.ArffFileParser</a>
</dt>
<dd>
<dl>
<dt>
<tt>-arff.baseparser</tt>
</dt>
<dd>parser getting the input translated from arff format to whitespace separated format<br/>Implementing de.lmu.ifi.dbs.elki.parser.Parser<br/>Known classes (default package de.lmu.ifi.dbs.elki.parser.):<br/>-&gt; BitVectorLabelParser<br/>-&gt; NumberDistanceParser<br/>-&gt; ParameterizationFunctionLabelParser<br/>-&gt; DoubleVectorLabelParser<br/>-&gt; FloatVectorLabelParser<br/>-&gt; DoubleVectorLabelTransposingParser<br/>-&gt; SparseBitVectorLabelParser<br/>Default: de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser"/>
<a href="de/lmu/ifi/dbs/elki/parser/DoubleVectorLabelParser.html">de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser</a>
</dt>
<dd>
<dl>
<dt>
<tt>-parser.classLabelIndex</tt>
</dt>
<dd>Index of a class label (may be numeric), counting whitespace separated entries in a line starting with 0 - the corresponding entry will be treated as a label. <br/>Default: -1.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelTransposingParser"/>
<a href="de/lmu/ifi/dbs/elki/parser/DoubleVectorLabelTransposingParser.html">de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelTransposingParser</a>
</dt>
<dd>
<dl>
<dt>
<tt>-parser.classLabelIndex</tt>
</dt>
<dd>Index of a class label (may be numeric), counting whitespace separated entries in a line starting with 0 - the corresponding entry will be treated as a label. <br/>Default: -1.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.parser.FloatVectorLabelParser"/>
<a href="de/lmu/ifi/dbs/elki/parser/FloatVectorLabelParser.html">de.lmu.ifi.dbs.elki.parser.FloatVectorLabelParser</a>
</dt>
<dd>
<dl>
<dt>
<tt>-parser.classLabelIndex</tt>
</dt>
<dd>Index of a class label (may be numeric), counting whitespace separated entries in a line starting with 0 - the corresponding entry will be treated as a label. <br/>Default: -1.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.parser.NumberDistanceParser"/>
<a href="de/lmu/ifi/dbs/elki/parser/NumberDistanceParser.html">de.lmu.ifi.dbs.elki.parser.NumberDistanceParser</a>
</dt>
<dd>
<dl>
<dt>
<tt>-parser.distancefunction</tt>
</dt>
<dd>Distance function.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.preprocessing.DiSHPreprocessor"/>
<a href="de/lmu/ifi/dbs/elki/preprocessing/DiSHPreprocessor.html">de.lmu.ifi.dbs.elki.preprocessing.DiSHPreprocessor</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dish.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered in each dimension for determination of the preference vector.<br/>Default: [0.0010].</dd>
<dt>
<tt>-dish.minpts</tt>
</dt>
<dd>positive threshold for minumum numbers of points in the epsilon-neighborhood of a point. The value of the preference vector in dimension d_i is set to 1 if the epsilon neighborhood contains more than dish.minpts points and the following condition holds: for all dimensions d_j: |neighbors(d_i) intersection neighbors(d_j)| &gt;= dish.minpts.<br/>Constraint: dish.minpts &gt; 0.</dd>
<dt>
<tt>-dish.strategy</tt>
</dt>
<dd>the strategy for determination of the preference vector, available strategies are: [APRIORI| MAX_INTERSECTION](default is MAX_INTERSECTION)<br/>Default: MAX_INTERSECTION.<br/>Constraint: dish.strategy in [APRIORI, MAX_INTERSECTION].</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.preprocessing.FourCPreprocessor"/>
<a href="de/lmu/ifi/dbs/elki/preprocessing/FourCPreprocessor.html">de.lmu.ifi.dbs.elki.preprocessing.FourCPreprocessor</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.<br/>Default: the maximum radius of the neighborhood to be considered, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction.</dd>
<dt>
<tt>-pca.filter.absolute</tt>
</dt>
<dd>Flag to mark delta as an absolute value.</dd>
<dt>
<tt>-pca.filter.delta</tt>
</dt>
<dd>The threshold for strong Eigenvalues. If not otherwise specified, delta is a relative value w.r.t. the (absolute) highest Eigenvalues and has to be a double between 0 and 1. To mark delta as an absolute value, use the option -pca.filter.absolute.<br/>Default: 0.01.<br/>Constraint: pca.filter.delta &gt;= 0.</dd>
<dt>
<tt>-projdbscan.distancefunction</tt>
</dt>
<dd>Distance function to determine the neighbors for variance analysis.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.preprocessing.FracClusPreprocessor"/>
<a href="de/lmu/ifi/dbs/elki/preprocessing/FracClusPreprocessor.html">de.lmu.ifi.dbs.elki.preprocessing.FracClusPreprocessor</a>
</dt>
<dd>
<dl>
<dt>
<tt>-supporters</tt>
</dt>
<dd>number of supporters (at least 2)<br/>Constraint: supporters &gt;= 2.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.preprocessing.HiSCPreprocessor"/>
<a href="de/lmu/ifi/dbs/elki/preprocessing/HiSCPreprocessor.html">de.lmu.ifi.dbs.elki.preprocessing.HiSCPreprocessor</a>
</dt>
<dd>
<dl>
<dt>
<tt>-hisc.alpha</tt>
</dt>
<dd>a double between 0 and 1 specifying the maximum absolute variance along a coordinate axis.<br/>Default: 0.01.<br/>Constraint: hisc.alpha in (0.0, 1.0).</dd>
<dt>
<tt>-hisc.k</tt>
</dt>
<dd>a positive integer specifying the number of nearest neighbors considered to determine the preference vector. If this value is not defined, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hisc.k &gt; 0.</dd>
<dt>
<tt>-hisc.k</tt>
</dt>
<dd>a positive integer specifying the number of nearest neighbors considered to determine the preference vector. If this value is not defined, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hisc.k &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.preprocessing.KernelFourCPreprocessor"/>
<a href="de/lmu/ifi/dbs/elki/preprocessing/KernelFourCPreprocessor.html">de.lmu.ifi.dbs.elki.preprocessing.KernelFourCPreprocessor</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.<br/>Default: the maximum radius of the neighborhood to be considered, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction.</dd>
<dt>
<tt>-pca.filter.absolute</tt>
</dt>
<dd>Flag to mark delta as an absolute value.</dd>
<dt>
<tt>-pca.filter.delta</tt>
</dt>
<dd>The threshold for strong Eigenvalues. If not otherwise specified, delta is a relative value w.r.t. the (absolute) highest Eigenvalues and has to be a double between 0 and 1. To mark delta as an absolute value, use the option -pca.filter.absolute.<br/>Default: 0.1.<br/>Constraint: pca.filter.delta &gt;= 0.</dd>
<dt>
<tt>-projdbscan.distancefunction</tt>
</dt>
<dd>Distance function to determine the neighbors for variance analysis.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.preprocessing.KnnQueryBasedHiCOPreprocessor"/>
<a href="de/lmu/ifi/dbs/elki/preprocessing/KnnQueryBasedHiCOPreprocessor.html">de.lmu.ifi.dbs.elki.preprocessing.KnnQueryBasedHiCOPreprocessor</a>
</dt>
<dd>
<dl>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.preprocessing.PreDeConPreprocessor"/>
<a href="de/lmu/ifi/dbs/elki/preprocessing/PreDeConPreprocessor.html">de.lmu.ifi.dbs.elki.preprocessing.PreDeConPreprocessor</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.<br/>Default: the maximum radius of the neighborhood to be considered, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction.</dd>
<dt>
<tt>-predecon.delta</tt>
</dt>
<dd>a double between 0 and 1 specifying the threshold for small Eigenvalues (default is delta = 0.01).<br/>Default: 0.01.<br/>Constraint: predecon.delta in (0.0, 1.0).</dd>
<dt>
<tt>-projdbscan.distancefunction</tt>
</dt>
<dd>Distance function to determine the neighbors for variance analysis.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.preprocessing.PreprocessorHandler"/>
<a href="de/lmu/ifi/dbs/elki/preprocessing/PreprocessorHandler.html">de.lmu.ifi.dbs.elki.preprocessing.PreprocessorHandler</a>
</dt>
<dd>
<dl>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>The Classname of the preprocessor to determine the neighbors of the objects.<br/>Extending de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessorDefault: de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>The Classname of the preprocessor to determine the neighbors of the objects.<br/>Extending de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessorDefault: de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>Preprocessor class to determine the correlation dimension of each object.<br/>Extending de.lmu.ifi.dbs.elki.preprocessing.HiCOPreprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; KnnQueryBasedHiCOPreprocessor<br/>-&gt; RangeQueryBasedHiCOPreprocessor<br/>Default: de.lmu.ifi.dbs.elki.preprocessing.KnnQueryBasedHiCOPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>Preprocessor class to determine the correlation dimension of each object.<br/>Implementing de.lmu.ifi.dbs.elki.preprocessing.Preprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; DiSHPreprocessor<br/>-&gt; FourCPreprocessor<br/>-&gt; HiSCPreprocessor<br/>-&gt; KnnQueryBasedHiCOPreprocessor<br/>-&gt; PreDeConPreprocessor<br/>-&gt; RangeQueryBasedHiCOPreprocessor<br/>Default: de.lmu.ifi.dbs.elki.preprocessing.KnnQueryBasedHiCOPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>Preprocessor class to determine the correlation dimension of each object.<br/>Implementing de.lmu.ifi.dbs.elki.preprocessing.Preprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; DiSHPreprocessor<br/>-&gt; FourCPreprocessor<br/>-&gt; HiSCPreprocessor<br/>-&gt; KnnQueryBasedHiCOPreprocessor<br/>-&gt; PreDeConPreprocessor<br/>-&gt; RangeQueryBasedHiCOPreprocessor<br/>Default: de.lmu.ifi.dbs.elki.preprocessing.KnnQueryBasedHiCOPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>Preprocessor class to determine the correlation dimension of each object.<br/>Implementing de.lmu.ifi.dbs.elki.preprocessing.Preprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; DiSHPreprocessor<br/>-&gt; FourCPreprocessor<br/>-&gt; HiSCPreprocessor<br/>-&gt; KnnQueryBasedHiCOPreprocessor<br/>-&gt; PreDeConPreprocessor<br/>-&gt; RangeQueryBasedHiCOPreprocessor<br/>Default: de.lmu.ifi.dbs.elki.preprocessing.KnnQueryBasedHiCOPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>Preprocessor class to determine the preference vector of each object.<br/>Implementing de.lmu.ifi.dbs.elki.preprocessing.PreferenceVectorPreprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; DiSHPreprocessor<br/>-&gt; HiSCPreprocessor<br/>Default: de.lmu.ifi.dbs.elki.preprocessing.HiSCPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>Preprocessor class to determine the correlation dimension of each object.<br/>Implementing de.lmu.ifi.dbs.elki.preprocessing.Preprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; DiSHPreprocessor<br/>-&gt; FourCPreprocessor<br/>-&gt; HiSCPreprocessor<br/>-&gt; KnnQueryBasedHiCOPreprocessor<br/>-&gt; PreDeConPreprocessor<br/>-&gt; RangeQueryBasedHiCOPreprocessor<br/>Default: de.lmu.ifi.dbs.elki.preprocessing.KnnQueryBasedHiCOPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>The Classname of the preprocessor to determine the neighbors of the objects.<br/>Extending de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessorDefault: de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>The Classname of the preprocessor to determine the neighbors of the objects.<br/>Extending experimentalcode.erich.oldtempdiscarded.MaterializeRankingPreprocessorDefault: experimentalcode.erich.oldtempdiscarded.MaterializeRankingPreprocessor.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.preprocessing.RangeQueryBasedHiCOPreprocessor"/>
<a href="de/lmu/ifi/dbs/elki/preprocessing/RangeQueryBasedHiCOPreprocessor.html">de.lmu.ifi.dbs.elki.preprocessing.RangeQueryBasedHiCOPreprocessor</a>
</dt>
<dd>
<dl>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-preprocessor.epsilon</tt>
</dt>
<dd>An epsilon value suitable to the specified distance function.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessor"/>
<a href="de/lmu/ifi/dbs/elki/preprocessing/SharedNearestNeighborsPreprocessor.html">de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessor</a>
</dt>
<dd>
<dl>
<dt>
<tt>-SNNDistanceFunction</tt>
</dt>
<dd>the distance function to asses the nearest neighbors<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-sharedNearestNeighbors</tt>
</dt>
<dd>number of nearest neighbors to consider (at least 1)<br/>Default: 1.<br/>Constraint: sharedNearestNeighbors &gt;= 1.</dd>
<dt>
<tt>-SNNDistanceFunction</tt>
</dt>
<dd>the distance function to asses the nearest neighbors<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-SNNDistanceFunction</tt>
</dt>
<dd>the distance function to asses the nearest neighbors<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-SNNDistanceFunction</tt>
</dt>
<dd>the distance function to asses the nearest neighbors<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.result.ResultWriter"/>
<a href="de/lmu/ifi/dbs/elki/result/ResultWriter.html">de.lmu.ifi.dbs.elki.result.ResultWriter</a>
</dt>
<dd>
<dl>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-out.gzip</tt>
</dt>
<dd>Enable gzip compression of output files.</dd>
<dt>
<tt>-out.silentoverwrite</tt>
</dt>
<dd>Silently overwrite output files.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.CASHWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/CASHWrapper.html">de.lmu.ifi.dbs.elki.wrapper.CASHWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-cash.maxlevel</tt>
</dt>
<dd>The maximum level for splitting the hypercube.<br/>Constraint: cash.maxlevel &gt; 0.</dd>
<dt>
<tt>-cash.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in a cluster.<br/>Constraint: cash.minpts &gt; 0.</dd>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.CLIQUEWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/CLIQUEWrapper.html">de.lmu.ifi.dbs.elki.wrapper.CLIQUEWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-clique.prune</tt>
</dt>
<dd>Flag to indicate that only subspaces with large coverage (i.e. the fraction of the database that is covered by the dense units) are selected, the rest will be pruned.</dd>
<dt>
<tt>-clique.tau</tt>
</dt>
<dd>The density threshold for the selectivity of a unit, where the selectivity isthe fraction of total feature vectors contained in this unit.<br/>Constraint: clique.tau in (0, 1).</dd>
<dt>
<tt>-clique.xsi</tt>
</dt>
<dd>The number of intervals (units) in each dimension.<br/>Constraint: clique.xsi &gt; 0.</dd>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.COPACWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/COPACWrapper.html">de.lmu.ifi.dbs.elki.wrapper.COPACWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considerd, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction</dd>
<dt>
<tt>-dbscan.minpts</tt>
</dt>
<dd> Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: dbscan.minpts &gt; 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to the value of dbscan.minpts<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.DBSCANWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/DBSCANWrapper.html">de.lmu.ifi.dbs.elki.wrapper.DBSCANWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considerd, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction<br/>Default: 1.0.</dd>
<dt>
<tt>-dbscan.minpts</tt>
</dt>
<dd> Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Default: 10.<br/>Constraint: dbscan.minpts &gt; 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.DeLiCluWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/DeLiCluWrapper.html">de.lmu.ifi.dbs.elki.wrapper.DeLiCluWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-deliclu.minpts</tt>
</dt>
<dd>Threshold for minimum number of points within a cluster.<br/>Default: 10.<br/>Constraint: deliclu.minpts &gt; 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.DependencyDerivatorWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/DependencyDerivatorWrapper.html">de.lmu.ifi.dbs.elki.wrapper.DependencyDerivatorWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.DiSHWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/DiSHWrapper.html">de.lmu.ifi.dbs.elki.wrapper.DiSHWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-dish.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered in each dimension for determination of the preference vector.<br/>Default: 0.0010.<br/>Constraint: dish.epsilon &gt;= 0.</dd>
<dt>
<tt>-dish.mu</tt>
</dt>
<dd>The minimum number of points as a smoothing factor to avoid the single-link-effekt.<br/>Default: 10.<br/>Constraint: dish.mu &gt; 0.</dd>
<dt>
<tt>-dish.strategy</tt>
</dt>
<dd>the strategy for determination of the preference vector, available strategies are: [APRIORI| MAX_INTERSECTION](default is MAX_INTERSECTION)<br/>Default: MAX_INTERSECTION.<br/>Constraint: dish.strategy in [APRIORI, MAX_INTERSECTION].</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.DirectoryTask"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/DirectoryTask.html">de.lmu.ifi.dbs.elki.wrapper.DirectoryTask</a>
</dt>
<dd>
<dl>
<dt>
<tt>-directorytask.wrapper</tt>
</dt>
<dd>Wrapper to run over all files in the specified directory..<br/>Implementing de.lmu.ifi.dbs.elki.wrapper.Wrapper</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.in</tt>
</dt>
<dd>The name of the directory to run the wrapper on.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>The name of the output file.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.ERiCWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/ERiCWrapper.html">de.lmu.ifi.dbs.elki.wrapper.ERiCWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-dbscan.minpts</tt>
</dt>
<dd> Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: dbscan.minpts &gt; 0.</dd>
<dt>
<tt>-ericdf.delta</tt>
</dt>
<dd>Threshold for approximate linear dependency: the strong eigenvectors of q are approximately linear dependent from the strong eigenvectors p if the following condition holds for all stroneg eigenvectors q_i of q (lambda_q &lt; lambda_p): q_i' * M^check_p * q_i &lt;= delta^2.<br/>Default: 0.1.<br/>Constraint: ericdf.delta &gt;= 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to the value of dbscan.minpts.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.FourCWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/FourCWrapper.html">de.lmu.ifi.dbs.elki.wrapper.FourCWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-pca.filter.absolute</tt>
</dt>
<dd>Flag to mark delta as an absolute value.</dd>
<dt>
<tt>-pca.filter.delta</tt>
</dt>
<dd>The threshold for strong Eigenvalues. If not otherwise specified, delta is a relative value w.r.t. the (absolute) highest Eigenvalues and has to be a double between 0 and 1. To mark delta as an absolute value, use the option -pca.filter.absolute.<br/>Default: 0.01.<br/>Constraints: pca.filter.delta &gt;= 0, pca.filter.delta &lt;= 1.</dd>
<dt>
<tt>-projdbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-projdbscan.lambda</tt>
</dt>
<dd>The intrinsic dimensionality of the clusters to find.<br/>Constraint: projdbscan.lambda &gt; 0.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.HiCOWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/HiCOWrapper.html">de.lmu.ifi.dbs.elki.wrapper.HiCOWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to the value of optics.minpts<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-optics.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: optics.minpts &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-pca.filter.alpha</tt>
</dt>
<dd>The share (0.0 to 1.0) of variance that needs to be explained by the 'strong' eigenvectors.The filter class will choose the number of strong eigenvectors by this share.<br/>Default: 0.85.<br/>Constraint: pca.filter.alpha in (0.0, 1.0).</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.HiSCWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/HiSCWrapper.html">de.lmu.ifi.dbs.elki.wrapper.HiSCWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-hisc.alpha</tt>
</dt>
<dd>a double between 0 and 1 specifying the maximum absolute variance along a coordinate axis.<br/>Default: 0.01.<br/>Constraint: hisc.alpha in (0.0, 1.0).</dd>
<dt>
<tt>-hisc.k</tt>
</dt>
<dd>a positive integer specifying the number of nearest neighbors considered to determine the preference vector. If this value is not defined, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hisc.k &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.LOFWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/LOFWrapper.html">de.lmu.ifi.dbs.elki.wrapper.LOFWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-lof.minpts</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its LOF.<br/>Constraint: lof.minpts &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.OPTICSWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/OPTICSWrapper.html">de.lmu.ifi.dbs.elki.wrapper.OPTICSWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-optics.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction</dd>
<dt>
<tt>-optics.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: optics.minpts &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.ORCLUSWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/ORCLUSWrapper.html">de.lmu.ifi.dbs.elki.wrapper.ORCLUSWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-projectedclustering.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: projectedclustering.k &gt; 0.</dd>
<dt>
<tt>-projectedclustering.k_i</tt>
</dt>
<dd>The multiplier for the initial number of seeds.<br/>Default: 30.<br/>Constraint: projectedclustering.k_i &gt; 0.</dd>
<dt>
<tt>-projectedclustering.l</tt>
</dt>
<dd>The dimensionality of the clusters to find.<br/>Constraint: projectedclustering.l &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.OnlineLOFWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/OnlineLOFWrapper.html">de.lmu.ifi.dbs.elki.wrapper.OnlineLOFWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-lof.minpts</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its LOF.<br/>Constraint: lof.minpts &gt; 0.</dd>
<dt>
<tt>-onlinelof.insertions</tt>
</dt>
<dd>The name of the file containing the objects to be inserted.</dd>
<dt>
<tt>-onlinelof.lof</tt>
</dt>
<dd>The name of the file containing the LOFs of the input file.</dd>
<dt>
<tt>-onlinelof.nn</tt>
</dt>
<dd>The name of the file containing the nearest neighbors of the input file.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.PROCLUSWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/PROCLUSWrapper.html">de.lmu.ifi.dbs.elki.wrapper.PROCLUSWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-projectedclustering.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: projectedclustering.k &gt; 0.</dd>
<dt>
<tt>-projectedclustering.k_i</tt>
</dt>
<dd>The multiplier for the initial number of seeds.<br/>Default: 30.<br/>Constraint: projectedclustering.k_i &gt; 0.</dd>
<dt>
<tt>-projectedclustering.l</tt>
</dt>
<dd>The dimensionality of the clusters to find.<br/>Constraint: projectedclustering.l &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.PreDeConWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/PreDeConWrapper.html">de.lmu.ifi.dbs.elki.wrapper.PreDeConWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-projdbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-projdbscan.lambda</tt>
</dt>
<dd>The intrinsic dimensionality of the clusters to find.<br/>Constraint: projdbscan.lambda &gt; 0.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="de.lmu.ifi.dbs.elki.wrapper.TransposedViewWrapper"/>
<a href="de/lmu/ifi/dbs/elki/wrapper/TransposedViewWrapper.html">de.lmu.ifi.dbs.elki.wrapper.TransposedViewWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out.gnu</tt>
</dt>
<dd>file to write the gnuplot script in.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.in</tt>
</dt>
<dd>The name of the input file.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>The name of the output file.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.arthur.CODECWrapper"/>
<a href="experimentalcode/arthur/CODECWrapper.html">experimentalcode.arthur.CODECWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considerd, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction</dd>
<dt>
<tt>-dbscan.minpts</tt>
</dt>
<dd> Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: dbscan.minpts &gt; 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to the value of dbscan.minpts<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.arthur.CoDeC"/>
<a href="experimentalcode/arthur/CoDeC.html">experimentalcode.arthur.CoDeC</a>
</dt>
<dd>
<dl>
<dt>
<tt>-codec.classify</tt>
</dt>
<dd>Flag to demand evaluation of the cluster-models as classifier.</dd>
<dt>
<tt>-codec.classlabel</tt>
</dt>
<dd>Class to use for class labels.<br/>Extending de.lmu.ifi.dbs.elki.data.ClassLabel<br/>Known classes (default package de.lmu.ifi.dbs.elki.data.):<br/>-&gt; SimpleClassLabel<br/>-&gt; HierarchicalClassLabel<br/>Default: de.lmu.ifi.dbs.elki.data.HierarchicalClassLabel.</dd>
<dt>
<tt>-codec.clusteringAlgorithm</tt>
</dt>
<dd>Clustering algorithm to use to derive clusters.<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.clustering.ClusteringAlgorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.clustering.):<br/>-&gt; correlation.COPAC<br/>-&gt; DBSCAN<br/>-&gt; EM<br/>-&gt; KMeans<br/>-&gt; SNNClustering<br/>-&gt; correlation.COPAC<br/>-&gt; correlation.FourC<br/>-&gt; correlation.ORCLUS<br/>-&gt; subspace.CLIQUE<br/>-&gt; subspace.PreDeCon<br/>-&gt; subspace.PROCLUS<br/>Default: de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.COPAC.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.arthur.FIRES"/>
<a href="experimentalcode/arthur/FIRES.html">experimentalcode.arthur.FIRES</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.arthur.LoggingTester"/>
<a href="experimentalcode/arthur/LoggingTester.html">experimentalcode.arthur.LoggingTester</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.arthur.ProjectedDatabase"/>
<a href="experimentalcode/arthur/ProjectedDatabase.html">experimentalcode.arthur.ProjectedDatabase</a>
</dt>
<dd>
<dl>
<dt>
<tt>-projecteddatabase.selecteddimensions</tt>
</dt>
<dd>a comma separated array of integer values d_i, where 1 &lt;= d_i &lt;= the dimensionality of the feature space specifying the dimensions to be considered for projection. If this parameter is not set, no dimensions will be considered, i.e. the projection is a zero-dimensional feature space<br/>Constraint: all elements of projecteddatabase.selecteddimensions &lt; 1.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.arthur.SubspaceAggregation"/>
<a href="experimentalcode/arthur/SubspaceAggregation.html">experimentalcode.arthur.SubspaceAggregation</a>
</dt>
<dd>
<dl>
<dt>
<tt>-subspaceagg.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: subspaceagg.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.arthur.SubspaceEM"/>
<a href="experimentalcode/arthur/SubspaceEM.html">experimentalcode.arthur.SubspaceEM</a>
</dt>
<dd>
<dl>
<dt>
<tt>-subspaceem.delta</tt>
</dt>
<dd>The termination criterion for maximization of E(M): E(M) - E(M') &lt; subspaceem.delta<br/>Default: 0.0.<br/>Constraint: subspaceem.delta &gt;= 0.0.</dd>
<dt>
<tt>-subspaceem.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: subspaceem.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.arthur.biclustering.NaivePatternBased"/>
<a href="experimentalcode/arthur/biclustering/NaivePatternBased.html">experimentalcode.arthur.biclustering.NaivePatternBased</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.elke.AlgorithmTest"/>
<a href="experimentalcode/elke/AlgorithmTest.html">experimentalcode.elke.AlgorithmTest</a>
</dt>
<dd>
<dl>
<dt>
<tt>-test.algorithms</tt>
</dt>
<dd>Comma separated list of classnames specifying the algorithms to be run with default parametrization. If this parameter is not set all algorithms as specified in the property file are used.</dd>
<dt>
<tt>-test.in</tt>
</dt>
<dd>The name of the input file to be parsed. This file is used for all specified algorithms as input file.</dd>
<dt>
<tt>-test.out</tt>
</dt>
<dd>Name of the directory to write the results of the specified algorithms in. The result of each algorithm is written into a file/directory with the name of the class of the according algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.elke.algorithm.ICA"/>
<a href="experimentalcode/elke/algorithm/ICA.html">experimentalcode.elke.algorithm.ICA</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.elke.algorithm.ICAWrapper"/>
<a href="experimentalcode/elke/algorithm/ICAWrapper.html">experimentalcode.elke.algorithm.ICAWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.elke.algorithm.SUBCLU"/>
<a href="experimentalcode/elke/algorithm/SUBCLU.html">experimentalcode.elke.algorithm.SUBCLU</a>
</dt>
<dd>
<dl>
<dt>
<tt>-subclu.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Extending de.lmu.ifi.dbs.elki.distance.distancefunction.AbstractDimensionsSelectingDoubleDistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.DimensionsSelectingEuclideanDistanceFunction.</dd>
<dt>
<tt>-subclu.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-subclu.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: subclu.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.elke.algorithm.SUBCLUWrapper"/>
<a href="experimentalcode/elke/algorithm/SUBCLUWrapper.html">experimentalcode.elke.algorithm.SUBCLUWrapper</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-subclu.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-subclu.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: subclu.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.elke.ica.FastICA"/>
<a href="experimentalcode/elke/ica/FastICA.html">experimentalcode.elke.ica.FastICA</a>
</dt>
<dd>
<dl>
<dt>
<tt>-fastica.app</tt>
</dt>
<dd>the approach to be used, available approaches are: [DEFLATION| SYMMETRIC]. Default: DEFLATION)<br/>Default: experimentalcode.elke.ica.FastICA$Approach.<br/>Constraint: fastica.app in [DEFLATION, SYMMETRIC].</dd>
<dt>
<tt>-fastica.epsilon</tt>
</dt>
<dd>a positive value defining the criterion for convergence of weight vector w_p: if the difference of the values of w_p after two iterations is less than or equal to epsilon. Default: 0.0010<br/>Default: 0.0010.<br/>Constraint: fastica.epsilon &gt; 0.</dd>
<dt>
<tt>-fastica.g</tt>
</dt>
<dd>Contrast function to be used to estimate negentropy.<br/>Implementing experimentalcode.elke.ica.ContrastFunctionDefault: experimentalcode.elke.ica.KurtosisBasedContrastFunction.</dd>
<dt>
<tt>-fastica.ic</tt>
</dt>
<dd>the maximum number of independent components (ics) to be found. The number of ics to be found must be less to or equal than the dimensionality of the feature space.<br/>Constraint: fastica.ic &gt; 0.</dd>
<dt>
<tt>-fastica.maxIter</tt>
</dt>
<dd>the number of maximum iterations. Default: 1000<br/>Default: 1000.<br/>Constraint: fastica.maxIter &gt; 0.</dd>
<dt>
<tt>-fastica.unit</tt>
</dt>
<dd>Flag that indicates that the unit matrix is used as initial weight matrix. If this flag is not set, the initial weight matrix will be generated randomly.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.elke.ica.TanhContrastFunction"/>
<a href="experimentalcode/elke/ica/TanhContrastFunction.html">experimentalcode.elke.ica.TanhContrastFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-tanh.a</tt>
</dt>
<dd>the parameter a of this function g(x) = tanh(a * x). Default: 1.0<br/>Default: 1.0.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.ReparseAndVisualize"/>
<a href="experimentalcode/erich/ReparseAndVisualize.html">experimentalcode.erich.ReparseAndVisualize</a>
</dt>
<dd>
<dl>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-resulthandler</tt>
</dt>
<dd>Result handler class.<br/>Implementing de.lmu.ifi.dbs.elki.result.ResultHandler<br/>Known classes (default package de.lmu.ifi.dbs.elki.result.):<br/>-&gt; ResultWriter<br/>-&gt; DiscardResultHandler<br/>Default: experimentalcode.erich.ResultVisualizeScatterplot.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.cache.DiskCacheBasedDoubleDistanceFunction"/>
<a href="experimentalcode/erich/cache/DiskCacheBasedDoubleDistanceFunction.html">experimentalcode.erich.cache.DiskCacheBasedDoubleDistanceFunction</a>
</dt>
<dd>
<dl>
<dt>
<tt>-distance.matrix</tt>
</dt>
<dd>The name of the file containing the distance matrix.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.cache.LoadDistanceResultIntoDiskCache"/>
<a href="experimentalcode/erich/cache/LoadDistanceResultIntoDiskCache.html">experimentalcode.erich.cache.LoadDistanceResultIntoDiskCache</a>
</dt>
<dd>
<dl>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-loader.diskcache</tt>
</dt>
<dd>File name of the disk cache to create.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.oldtempdiscarded.DistanceStatistics"/>
<a href="experimentalcode/erich/oldtempdiscarded/DistanceStatistics.html">experimentalcode.erich.oldtempdiscarded.DistanceStatistics</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.oldtempdiscarded.DistanceStatisticsWithClasses"/>
<a href="experimentalcode/erich/oldtempdiscarded/DistanceStatisticsWithClasses.html">experimentalcode.erich.oldtempdiscarded.DistanceStatisticsWithClasses</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.oldtempdiscarded.KNNClassifierQuality"/>
<a href="experimentalcode/erich/oldtempdiscarded/KNNClassifierQuality.html">experimentalcode.erich.oldtempdiscarded.KNNClassifierQuality</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.oldtempdiscarded.KNNClassifierQuality2"/>
<a href="experimentalcode/erich/oldtempdiscarded/KNNClassifierQuality2.html">experimentalcode.erich.oldtempdiscarded.KNNClassifierQuality2</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.oldtempdiscarded.MaterializeRankingPreprocessor"/>
<a href="experimentalcode/erich/oldtempdiscarded/MaterializeRankingPreprocessor.html">experimentalcode.erich.oldtempdiscarded.MaterializeRankingPreprocessor</a>
</dt>
<dd>
<dl>
<dt>
<tt>-RankingDistanceFunction</tt>
</dt>
<dd>the distance function to obtain the ranking<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-materializeK</tt>
</dt>
<dd>number of nearest neighbors to materialize (at least 1, 0 means full dataset, default)<br/>Default: 0.<br/>Constraint: materializeK &gt;= 0.</dd>
<dt>
<tt>-RankingDistanceFunction</tt>
</dt>
<dd>the distance function to obtain the ranking<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.pca.MultivariateCorrelationOutlierProbability"/>
<a href="experimentalcode/erich/pca/MultivariateCorrelationOutlierProbability.html">experimentalcode.erich.pca.MultivariateCorrelationOutlierProbability</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-mcop.k</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its MCOP.<br/>Constraint: mcop.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.pca.MultivariateModelDerivator"/>
<a href="experimentalcode/erich/pca/MultivariateModelDerivator.html">experimentalcode.erich.pca.MultivariateModelDerivator</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-derivator.randomSample</tt>
</dt>
<dd>Flag to use random sample (use knn query around centroid, if flag is not set).</dd>
<dt>
<tt>-derivator.sampleSize</tt>
</dt>
<dd>Threshold for the size of the random sample to use. Default value is size of the complete dataset.<br/>Constraint: derivator.sampleSize &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.pca.OOScaR"/>
<a href="experimentalcode/erich/pca/OOScaR.html">experimentalcode.erich.pca.OOScaR</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-ooscar.inneralg</tt>
</dt>
<dd>Inner algorithm to run.<br/>Extending de.lmu.ifi.dbs.elki.algorithm.DistanceBasedAlgorithmDefault: de.lmu.ifi.dbs.elki.algorithm.clustering.DBSCAN.</dd>
<dt>
<tt>-ooscar.innerdistance</tt>
</dt>
<dd>Distance function for the inner algorithm.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: experimentalcode.erich.pca.OrientationDistanceFunction.</dd>
<dt>
<tt>-ooscar.k</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its COP.<br/>Constraint: ooscar.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.pca.PCAFilteredAutotuningRunner"/>
<a href="experimentalcode/erich/pca/PCAFilteredAutotuningRunner.html">experimentalcode.erich.pca.PCAFilteredAutotuningRunner</a>
</dt>
<dd>
<dl>
<dt>
<tt>-localpca.big</tt>
</dt>
<dd>A constant big value to reset high eigenvalues.<br/>Default: 1.0.<br/>Constraint: localpca.big &gt; 0.</dd>
<dt>
<tt>-localpca.small</tt>
</dt>
<dd>A constant small value to reset low eigenvalues.<br/>Default: 0.0.<br/>Constraint: localpca.small &gt;= 0.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.reparser.DirectoryReparser"/>
<a href="experimentalcode/erich/reparser/DirectoryReparser.html">experimentalcode.erich.reparser.DirectoryReparser</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.database</tt>
</dt>
<dd>Database to be provided by the parse method.<br/>Implementing de.lmu.ifi.dbs.elki.database.Database<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.):<br/>-&gt; MetricalIndexDatabase<br/>-&gt; SequentialDatabase<br/>-&gt; SpatialIndexDatabase<br/>Default: de.lmu.ifi.dbs.elki.database.SequentialDatabase.</dd>
<dt>
<tt>-reparser.dir</tt>
</dt>
<dd>The name of the directory to be parsed.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.erich.reparser.InputStreamReparser"/>
<a href="experimentalcode/erich/reparser/InputStreamReparser.html">experimentalcode.erich.reparser.InputStreamReparser</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc.parser</tt>
</dt>
<dd>Parser class to provide a database.<br/>Implementing de.lmu.ifi.dbs.elki.parser.LinebasedParser<br/>Known classes (default package de.lmu.ifi.dbs.elki.parser.):<br/>-&gt; DoubleVectorLabelParser<br/>-&gt; FloatVectorLabelParser<br/>-&gt; DoubleVectorLabelTransposingParser<br/>Default: de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.lisa.ConvexHullOutlierDetection"/>
<a href="experimentalcode/lisa/ConvexHullOutlierDetection.html">experimentalcode.lisa.ConvexHullOutlierDetection</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.lisa.DBOutlierDetection"/>
<a href="experimentalcode/lisa/DBOutlierDetection.html">experimentalcode.lisa.DBOutlierDetection</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-dbod.d</tt>
</dt>
<dd>size of the D-neighborhood</dd>
<dt>
<tt>-dbod.p</tt>
</dt>
<dd>minimum fraction of objects that must be outside the D-neigborhood of an outlier</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.lisa.EMOutlierDetection"/>
<a href="experimentalcode/lisa/EMOutlierDetection.html">experimentalcode.lisa.EMOutlierDetection</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.lisa.EvolutionaryOutlierDetection"/>
<a href="experimentalcode/lisa/EvolutionaryOutlierDetection.html">experimentalcode.lisa.EvolutionaryOutlierDetection</a>
</dt>
<dd>
<dl>
<dt>
<tt>-eod.r</tt>
</dt>
<dd>number of equi-depth ranges</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.lisa.GaussianModelOutlierDetection"/>
<a href="experimentalcode/lisa/GaussianModelOutlierDetection.html">experimentalcode.lisa.GaussianModelOutlierDetection</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.lisa.GridBasedROS"/>
<a href="experimentalcode/lisa/GridBasedROS.html">experimentalcode.lisa.GridBasedROS</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-gbros.r</tt>
</dt>
<dd>number of partitions on each axis<br/>Constraint: all elements of gbros.r &lt; 0.</dd>
<dt>
<tt>-rbo.k</tt>
</dt>
<dd>The number of nearest neighbors</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.lisa.KNNIntegralOutlierDetection"/>
<a href="experimentalcode/lisa/KNNIntegralOutlierDetection.html">experimentalcode.lisa.KNNIntegralOutlierDetection</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-knnio.k</tt>
</dt>
<dd>kth nearest neighbor</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.lisa.KNNOutlierDetection"/>
<a href="experimentalcode/lisa/KNNOutlierDetection.html">experimentalcode.lisa.KNNOutlierDetection</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-knno.k</tt>
</dt>
<dd>kth nearest neighbor</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.lisa.MixtureModelOutlierDetection"/>
<a href="experimentalcode/lisa/MixtureModelOutlierDetection.html">experimentalcode.lisa.MixtureModelOutlierDetection</a>
</dt>
<dd>
<dl>
<dt>
<tt>-mmo.c</tt>
</dt>
<dd>cutoff</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.lisa.RandomReferencePointsROS"/>
<a href="experimentalcode/lisa/RandomReferencePointsROS.html">experimentalcode.lisa.RandomReferencePointsROS</a>
</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-rbo.k</tt>
</dt>
<dd>The number of nearest neighbors</dd>
<dt>
<tt>-rrros.r</tt>
</dt>
<dd>number of partitions on each axis<br/>Default: 3.<br/>Constraint: rrros.r &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.noemi.ChengAndChurch"/>
<a href="experimentalcode/noemi/ChengAndChurch.html">experimentalcode.noemi.ChengAndChurch</a>
</dt>
<dd>
<dl>
<dt>
<tt>-chengandchurch.alpha</tt>
</dt>
<dd>parameter for multiple node deletion to accelerate the algorithm <br/>Constraint: chengandchurch.alpha &gt;= 1.0.</dd>
<dt>
<tt>-chengandchurch.begin</tt>
</dt>
<dd>lower limit for maskingValues</dd>
<dt>
<tt>-chengandchurch.end</tt>
</dt>
<dd>upper limit for maskingValues</dd>
<dt>
<tt>-chengandchurch.missing</tt>
</dt>
<dd>missing Value in database to be raplaced with maskingValues</dd>
<dt>
<tt>-chengandchurch.multipleAddition</tt>
</dt>
<dd>indicates how many times the algorithm to add Nodes should be performed<br/>Default: 1.<br/>Constraint: chengandchurch.multipleAddition &gt;= 1.</dd>
<dt>
<tt>-chengandchurch.n</tt>
</dt>
<dd>number of biclusters to be found <br/>Default: 1.<br/>Constraint: chengandchurch.n &gt;= 1.</dd>
<dt>
<tt>-chengandchurch.random</tt>
</dt>
<dd>seed for initializing random list for the masking values<br/>Default: 1.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.noemi.FIRES"/>
<a href="experimentalcode/noemi/FIRES.html">experimentalcode.noemi.FIRES</a>
</dt>
<dd>
<dl>
<dt>
<tt>-fires.baseAlgorithm</tt>
</dt>
<dd>indicates which algorithm is used for calculating the onedimensional base clusters<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.clustering.ClusteringAlgorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.clustering.):<br/>-&gt; correlation.COPAC<br/>-&gt; DBSCAN<br/>-&gt; EM<br/>-&gt; KMeans<br/>-&gt; SNNClustering<br/>-&gt; correlation.COPAC<br/>-&gt; correlation.FourC<br/>-&gt; correlation.ORCLUS<br/>-&gt; subspace.CLIQUE<br/>-&gt; subspace.PreDeCon<br/>-&gt; subspace.PROCLUS</dd>
<dt>
<tt>-fires.intersection</tt>
</dt>
<dd>indicates if the refinement step should be applied upon the union or upon the intersection of base-clusters within a SubspaceClusterApproximation</dd>
<dt>
<tt>-fires.minClu</tt>
</dt>
<dd>minimal size a Best Merge Candidate must have to be cosidered a Best Merge Cluster<br/>Constraint: fires.minClu &gt;= 1.</dd>
<dt>
<tt>-fires.refinementAlgorithm</tt>
</dt>
<dd>indicates which algorithm is used for calculating the onedimensional postprocessing clusters<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.clustering.ClusteringAlgorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.clustering.):<br/>-&gt; correlation.COPAC<br/>-&gt; DBSCAN<br/>-&gt; EM<br/>-&gt; KMeans<br/>-&gt; SNNClustering<br/>-&gt; correlation.COPAC<br/>-&gt; correlation.FourC<br/>-&gt; correlation.ORCLUS<br/>-&gt; subspace.CLIQUE<br/>-&gt; subspace.PreDeCon<br/>-&gt; subspace.PROCLUS</dd>
<dt>
<tt>-fires.thresholdBMC</tt>
</dt>
<dd>threshold for the minimal number of intersections the MSC of a best merge candidate of c (=BMC(c)) must have with MSC(c)<br/>Constraint: fires.thresholdBMC &gt;= 0.</dd>
<dt>
<tt>-fires.thresholdMSC</tt>
</dt>
<dd>threshold for the minimal number of Most Similar Clusters (MSCs)<br/>Constraint: fires.thresholdMSC &gt;= 1.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.noemi.FIRES2"/>
<a href="experimentalcode/noemi/FIRES2.html">experimentalcode.noemi.FIRES2</a>
</dt>
<dd>
<dl>
<dt>
<tt>-fires.baseAlgorithm</tt>
</dt>
<dd>indicates which algorithm is used for calculating the onedimensional base clusters<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.clustering.ClusteringAlgorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.clustering.):<br/>-&gt; correlation.COPAC<br/>-&gt; DBSCAN<br/>-&gt; EM<br/>-&gt; KMeans<br/>-&gt; SNNClustering<br/>-&gt; correlation.COPAC<br/>-&gt; correlation.FourC<br/>-&gt; correlation.ORCLUS<br/>-&gt; subspace.CLIQUE<br/>-&gt; subspace.PreDeCon<br/>-&gt; subspace.PROCLUS</dd>
<dt>
<tt>-fires.minClu</tt>
</dt>
<dd>minimal size a Best Merge Candidate must have to be cosidered a Best Merge Cluster<br/>Constraint: fires.minClu &gt;= 1.</dd>
<dt>
<tt>-fires.refinementAlgorithm</tt>
</dt>
<dd>indicates which algorithm is used for calculating the onedimensional postprocessing clusters<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.clustering.ClusteringAlgorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.clustering.):<br/>-&gt; correlation.COPAC<br/>-&gt; DBSCAN<br/>-&gt; EM<br/>-&gt; KMeans<br/>-&gt; SNNClustering<br/>-&gt; correlation.COPAC<br/>-&gt; correlation.FourC<br/>-&gt; correlation.ORCLUS<br/>-&gt; subspace.CLIQUE<br/>-&gt; subspace.PreDeCon<br/>-&gt; subspace.PROCLUS</dd>
<dt>
<tt>-fires.thresholdBMC</tt>
</dt>
<dd>threshold for the minimal number of intersections the MSC of a best merge candidate of c (=BMC(c)) must have with MSC(c)<br/>Constraint: fires.thresholdBMC &gt;= 0.</dd>
<dt>
<tt>-fires.thresholdMSC</tt>
</dt>
<dd>threshold for the minimal number of Most Similar Clusters (MSCs)<br/>Constraint: fires.thresholdMSC &gt;= 1.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.noemi.FIRESold"/>
<a href="experimentalcode/noemi/FIRESold.html">experimentalcode.noemi.FIRESold</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.noemi.FIRESusingDBSCAN"/>
<a href="experimentalcode/noemi/FIRESusingDBSCAN.html">experimentalcode.noemi.FIRESusingDBSCAN</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.noemi.FLOC"/>
<a href="experimentalcode/noemi/FLOC.html">experimentalcode.noemi.FLOC</a>
</dt>
<dd>
<dl>
<dt>
<tt>-floc.actionOrder</tt>
</dt>
<dd>specifies the order of actions<br/>Default: 0.<br/>Constraint: floc.actionOrder &gt;= 0.</dd>
<dt>
<tt>-floc.initialColDim</tt>
</dt>
<dd>Parameter to approximate the columnDimension of a initial bicluster<br/>Constraint: floc.initialColDim &lt;= 1.0.</dd>
<dt>
<tt>-floc.k</tt>
</dt>
<dd>indicates how many biclusters should be found<br/>Default: 1.<br/>Constraint: floc.k &gt;= 1.</dd>
<dt>
<tt>-floc.seed</tt>
</dt>
<dd>seed for initial clusters<br/>Default: 1.<br/>Constraint: floc.seed &gt;= 1.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.noemi.MaPle"/>
<a href="experimentalcode/noemi/MaPle.html">experimentalcode.noemi.MaPle</a>
</dt>
<dd>
<dl>
<dt>
<tt>-maple.nc</tt>
</dt>
<dd>indicates the minimum columnsize of the resulting biclusters<br/>Constraint: maple.nc &gt;= 1.</dd>
<dt>
<tt>-maple.nr</tt>
</dt>
<dd>indicates the minimum rowsize of the resulting biclusters<br/>Constraint: maple.nr &gt;= 1.</dd>
<dt>
<tt>-maple.sigma</tt>
</dt>
<dd>treshhold value to determine the maximal acceptable score of a bicluster<br/>Constraint: maple.sigma &gt;= 0.0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.noemi.PClustering"/>
<a href="experimentalcode/noemi/PClustering.html">experimentalcode.noemi.PClustering</a>
</dt>
<dd>
<dl>
<dt>
<tt>-pclustering.nc</tt>
</dt>
<dd>indicates the minimum columnsize of the resulting biclusters<br/>Constraint: pclustering.nc &gt;= 1.</dd>
<dt>
<tt>-pclustering.nr</tt>
</dt>
<dd>indicates the minimum rowsize of the resulting biclusters<br/>Constraint: pclustering.nr &gt;= 1.</dd>
<dt>
<tt>-pclustering.sigma</tt>
</dt>
<dd>treshhold value to determine the maximal acceptable score of a bicluster<br/>Constraint: pclustering.sigma &gt;= 0.0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.simon.NaivePatternBased"/>
<a href="experimentalcode/simon/NaivePatternBased.html">experimentalcode.simon.NaivePatternBased</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.tobias.rknnjoin.RkNNJoin"/>
<a href="experimentalcode/tobias/rknnjoin/RkNNJoin.html">experimentalcode.tobias.rknnjoin.RkNNJoin</a>
</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.tobias.rknnjoin.RkNNJoinTreeTraversal"/>
<a href="experimentalcode/tobias/rknnjoin/RkNNJoinTreeTraversal.html">experimentalcode.tobias.rknnjoin.RkNNJoinTreeTraversal</a>
</dt>
<dd>
<dl>
<dt>
<tt>-dbc2</tt>
</dt>
<dd>Database connection class.<br/>Implementing de.lmu.ifi.dbs.elki.database.connection.DatabaseConnection<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.connection.):<br/>-&gt; FileBasedDatabaseConnection<br/>-&gt; InputStreamDatabaseConnection<br/>-&gt; MultipleFileBasedDatabaseConnection<br/>Default: de.lmu.ifi.dbs.elki.database.connection.FileBasedDatabaseConnection.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>
<a name="experimentalcode.tobias.rknnjoin.structures.artree.ARStarTree"/>
<a href="experimentalcode/tobias/rknnjoin/structures/artree/ARStarTree.html">experimentalcode.tobias.rknnjoin.structures.artree.ARStarTree</a>
</dt>
<dd>
<dl>
<dt>
<tt>-spatial.bulk</tt>
</dt>
<dd>flag to specify bulk load (default is no bulk load)</dd>
<dt>
<tt>-spatial.bulkstrategy</tt>
</dt>
<dd>the strategy for bulk load, available strategies are: [MAX_EXTENSION| ZCURVE](default is ZCURVE)<br/>Default: ZCURVE.<br/>Constraint: spatial.bulkstrategy in [MAX_EXTENSION, ZCURVE].</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
</dl>
</body>
</html>
