<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Command line parameter overview.</title>
</head>
<body>
<!--WARNING: THIS DOCUMENT IS AUTOMATICALLY GENERATED. MODIFICATIONS MAY GET LOST.-->
<h1>ELKI command line parameter overview:</h1>
<dl>
<dt>{@link de.lmu.ifi.dbs.elki.preprocessing.DiSHPreprocessor}</dt>
<dd>
<dl>
<dt>
<tt>-dish.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered in each dimension for determination of the preference vector.<br/>Default: [0.0010].</dd>
<dt>
<tt>-dish.minpts</tt>
</dt>
<dd>positive threshold for minumum numbers of points in the epsilon-neighborhood of a point. The value of the preference vector in dimension d_i is set to 1 if the epsilon neighborhood contains more than dish.minpts points and the following condition holds: for all dimensions d_j: |neighbors(d_i) intersection neighbors(d_j)| &gt;= dish.minpts.<br/>Constraint: dish.minpts &gt; 0.</dd>
<dt>
<tt>-dish.strategy</tt>
</dt>
<dd>the strategy for determination of the preference vector, available strategies are: [APRIORI| MAX_INTERSECTION](default is MAX_INTERSECTION)<br/>Default: MAX_INTERSECTION.<br/>Constraint: dish.strategy in [APRIORI, MAX_INTERSECTION].</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.preprocessing.HiSCPreprocessor}</dt>
<dd>
<dl>
<dt>
<tt>-hisc.alpha</tt>
</dt>
<dd>a double between 0 and 1 specifying the maximum absolute variance along a coordinate axis.<br/>Default: 0.01.<br/>Constraint: hisc.alpha in (0.0, 1.0).</dd>
<dt>
<tt>-hisc.k</tt>
</dt>
<dd>a positive integer specifying the number of nearest neighbors considered to determine the preference vector. If this value is not defined, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hisc.k &gt; 0.</dd>
<dt>
<tt>-hisc.k</tt>
</dt>
<dd>a positive integer specifying the number of nearest neighbors considered to determine the preference vector. If this value is not defined, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hisc.k &gt; 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.index.tree.spatial.rstarvariants.deliclu.DeLiCluTree}</dt>
<dd>
<dl>
<dt>
<tt>-spatial.bulk</tt>
</dt>
<dd>flag to specify bulk load (default is no bulk load)</dd>
<dt>
<tt>-spatial.bulkstrategy</tt>
</dt>
<dd>the strategy for bulk load, available strategies are: [MAX_EXTENSION| ZCURVE](default is ZCURVE)<br/>Default: ZCURVE.<br/>Constraint: spatial.bulkstrategy in [MAX_EXTENSION, ZCURVE].</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.SimilarityAdapterLinear}</dt>
<dd>
<dl>
<dt>
<tt>-adapter.similarityfunction</tt>
</dt>
<dd>Similarity function to derive the distance between database objects from.<br/>Implementing de.lmu.ifi.dbs.elki.distance.similarityfunction.NormalizedSimilarityFunctionDefault: de.lmu.ifi.dbs.elki.distance.similarityfunction.FractionalSharedNearestNeighborSimilarityFunction.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.DeLiCluWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-deliclu.minpts</tt>
</dt>
<dd>Threshold for minimum number of points within a cluster.<br/>Default: 10.<br/>Constraint: deliclu.minpts &gt; 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.pca.MultivariateModelDerivator}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-derivator.randomSample</tt>
</dt>
<dd>Flag to use random sample (use knn query around centroid, if flag is not set).</dd>
<dt>
<tt>-derivator.sampleSize</tt>
</dt>
<dd>Threshold for the size of the random sample to use. Default value is size of the complete dataset.<br/>Constraint: derivator.sampleSize &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessor}</dt>
<dd>
<dl>
<dt>
<tt>-SNNDistanceFunction</tt>
</dt>
<dd>the distance function to asses the nearest neighbors<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-sharedNearestNeighbors</tt>
</dt>
<dd>number of nearest neighbors to consider (at least 1)<br/>Default: 1.<br/>Constraint: sharedNearestNeighbors &gt;= 1.</dd>
<dt>
<tt>-SNNDistanceFunction</tt>
</dt>
<dd>the distance function to asses the nearest neighbors<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-SNNDistanceFunction</tt>
</dt>
<dd>the distance function to asses the nearest neighbors<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-SNNDistanceFunction</tt>
</dt>
<dd>the distance function to asses the nearest neighbors<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.KNNJoin}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-knnjoin.k</tt>
</dt>
<dd>Specifies the k-nearest neighbors to be assigned.<br/>Default: 1.<br/>Constraint: knnjoin.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.parser.NumberDistanceParser}</dt>
<dd>
<dl>
<dt>
<tt>-parser.distancefunction</tt>
</dt>
<dd>Distance function.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.subspace.PreDeCon}</dt>
<dd>
<dl>
<dt>
<tt>-projdbscan.distancefunction</tt>
</dt>
<dd>Distance function to determine the neighbors for variance analysis.<br/>Extending de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction</dd>
<dt>
<tt>-projdbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-projdbscan.lambda</tt>
</dt>
<dd>The intrinsic dimensionality of the clusters to find.<br/>Constraint: projdbscan.lambda &gt; 0.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.SimilarityAdapterArccos}</dt>
<dd>
<dl>
<dt>
<tt>-adapter.similarityfunction</tt>
</dt>
<dd>Similarity function to derive the distance between database objects from.<br/>Implementing de.lmu.ifi.dbs.elki.distance.similarityfunction.NormalizedSimilarityFunctionDefault: de.lmu.ifi.dbs.elki.distance.similarityfunction.FractionalSharedNearestNeighborSimilarityFunction.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.arthur.SubspaceEM}</dt>
<dd>
<dl>
<dt>
<tt>-subspaceem.delta</tt>
</dt>
<dd>The termination criterion for maximization of E(M): E(M) - E(M') &lt; subspaceem.delta<br/>Default: 0.0.<br/>Constraint: subspaceem.delta &gt;= 0.0.</dd>
<dt>
<tt>-subspaceem.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: subspaceem.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.elke.ica.TanhContrastFunction}</dt>
<dd>
<dl>
<dt>
<tt>-tanh.a</tt>
</dt>
<dd>the parameter a of this function g(x) = tanh(a * x). Default: 1.0<br/>Default: 1.0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.preprocessing.FracClusPreprocessor}</dt>
<dd>
<dl>
<dt>
<tt>-supporters</tt>
</dt>
<dd>number of supporters (at least 2)<br/>Constraint: supporters &gt;= 2.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.evaluation.holdout.StratifiedCrossValidation}</dt>
<dd>
<dl>
<dt>
<tt>-nfold</tt>
</dt>
<dd>positive number of folds for cross-validation<br/>Default: 10.<br/>Constraint: nfold &gt; 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.DirectoryTask}</dt>
<dd>
<dl>
<dt>
<tt>-directorytask.wrapper</tt>
</dt>
<dd>Wrapper to run over all files in the specified directory..<br/>Implementing de.lmu.ifi.dbs.elki.wrapper.Wrapper</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.in</tt>
</dt>
<dd>The name of the directory to run the wrapper on.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>The name of the output file.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.statistics.EvaluateRankingQuality}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.elke.algorithm.ICAWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.TrivialAllNoise}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.ByLabelHierarchicalClustering}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.noemi.FLOC}</dt>
<dd>
<dl>
<dt>
<tt>-floc.actionOrder</tt>
</dt>
<dd>specifies the order of actions<br/>Default: 0.<br/>Constraint: floc.actionOrder &gt;= 0.</dd>
<dt>
<tt>-floc.initialColDim</tt>
</dt>
<dd>Parameter to approximate the columnDimension of a initial bicluster<br/>Constraint: floc.initialColDim &lt;= 1.0.</dd>
<dt>
<tt>-floc.k</tt>
</dt>
<dd>indicates how many biclusters should be found<br/>Default: 1.<br/>Constraint: floc.k &gt;= 1.</dd>
<dt>
<tt>-floc.seed</tt>
</dt>
<dd>seed for initial clusters<br/>Default: 1.<br/>Constraint: floc.seed &gt;= 1.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.preprocessing.PreDeConPreprocessor}</dt>
<dd>
<dl>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.<br/>Default: the maximum radius of the neighborhood to be considered, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction.</dd>
<dt>
<tt>-predecon.delta</tt>
</dt>
<dd>a double between 0 and 1 specifying the threshold for small Eigenvalues (default is delta = 0.01).<br/>Default: 0.01.<br/>Constraint: predecon.delta in (0.0, 1.0).</dd>
<dt>
<tt>-projdbscan.distancefunction</tt>
</dt>
<dd>Distance function to determine the neighbors for variance analysis.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.PolynomialKernelFunction}</dt>
<dd>
<dl>
<dt>
<tt>-kernel.degree</tt>
</dt>
<dd>The degree of the polynomial kernel function. Default: 2.0<br/>Default: 2.0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.HiCOWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to the value of optics.minpts<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-optics.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: optics.minpts &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-pca.filter.alpha</tt>
</dt>
<dd>The share (0.0 to 1.0) of variance that needs to be explained by the 'strong' eigenvectors.The filter class will choose the number of strong eigenvectors by this share.<br/>Default: 0.85.<br/>Constraint: pca.filter.alpha in (0.0, 1.0).</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.classifier.KNNClassifier}</dt>
<dd>
<dl>
<dt>
<tt>-classifier.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-knnclassifier.k</tt>
</dt>
<dd>The number of neighbors to take into account for classification.<br/>Default: 1.<br/>Constraint: knnclassifier.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.converter.Txt2Arff}</dt>
<dd>
<dl>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.in</tt>
</dt>
<dd>The name of the txt-file to convert.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>the arff-file to write the converted txt-file in.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.OPTICS}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-optics.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-optics.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: optics.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.arthur.FIRES}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.reparser.DirectoryReparser}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.database</tt>
</dt>
<dd>Database to be provided by the parse method.<br/>Implementing de.lmu.ifi.dbs.elki.database.Database<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.):<br/>-&gt; MetricalIndexDatabase<br/>-&gt; SequentialDatabase<br/>-&gt; SpatialIndexDatabase<br/>Default: de.lmu.ifi.dbs.elki.database.SequentialDatabase.</dd>
<dt>
<tt>-reparser.dir</tt>
</dt>
<dd>The name of the directory to be parsed.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.ORCLUSWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-projectedclustering.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: projectedclustering.k &gt; 0.</dd>
<dt>
<tt>-projectedclustering.k_i</tt>
</dt>
<dd>The multiplier for the initial number of seeds.<br/>Default: 30.<br/>Constraint: projectedclustering.k_i &gt; 0.</dd>
<dt>
<tt>-projectedclustering.l</tt>
</dt>
<dd>The dimensionality of the clusters to find.<br/>Constraint: projectedclustering.l &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.elke.algorithm.ICA}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.FileBasedFloatDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-distance.matrix</tt>
</dt>
<dd>The name of the file containing the distance matrix.</dd>
<dt>
<tt>-distance.parser</tt>
</dt>
<dd>Parser used to load the distance matrix.<br/>Implementing de.lmu.ifi.dbs.elki.parser.DistanceParserDefault: de.lmu.ifi.dbs.elki.parser.NumberDistanceParser.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.preprocessing.FourCPreprocessor}</dt>
<dd>
<dl>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.<br/>Default: the maximum radius of the neighborhood to be considered, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction.</dd>
<dt>
<tt>-pca.filter.absolute</tt>
</dt>
<dd>Flag to mark delta as an absolute value.</dd>
<dt>
<tt>-pca.filter.delta</tt>
</dt>
<dd>The threshold for strong Eigenvalues. If not otherwise specified, delta is a relative value w.r.t. the (absolute) highest Eigenvalues and has to be a double between 0 and 1. To mark delta as an absolute value, use the option -pca.filter.absolute.<br/>Default: 0.01.<br/>Constraint: pca.filter.delta &gt;= 0.</dd>
<dt>
<tt>-projdbscan.distancefunction</tt>
</dt>
<dd>Distance function to determine the neighbors for variance analysis.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.RepresentationSelectingDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-distancefunctions</tt>
</dt>
<dd>A comma separated list of the distance functions to determine the distance between objects within one representation.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.LOFWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-lof.minpts</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its LOF.<br/>Constraint: lof.minpts &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.classifier.PriorProbabilityClassifier}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.math.linearalgebra.pca.LimitEigenPairFilter}</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.absolute</tt>
</dt>
<dd>Flag to mark delta as an absolute value.</dd>
<dt>
<tt>-pca.filter.delta</tt>
</dt>
<dd>The threshold for strong Eigenvalues. If not otherwise specified, delta is a relative value w.r.t. the (absolute) highest Eigenvalues and has to be a double between 0 and 1. To mark delta as an absolute value, use the option -pca.filter.absolute.<br/>Default: 0.01.<br/>Constraint: pca.filter.delta &gt;= 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.data.synthetic.ArbitraryCorrelationGenerator}</dt>
<dd>
<dl>
<dt>
<tt>-acg.basis</tt>
</dt>
<dd>a list of basis vectors of the correlation hyperplane, where c denotes the correlation dimensionality and d the dimensionality of the feature space. Each basis vector is separated by :, the coordinates within the basis vectors are separated by a comma. If no basis is specified, the basis vectors are generated randomly.</dd>
<dt>
<tt>-acg.gaussian</tt>
</dt>
<dd>flag to indicate gaussian distribution, default is an equal distribution.</dd>
<dt>
<tt>-acg.point</tt>
</dt>
<dd>a comma separated list of the coordinates of the model point, default is the centroid of the defined feature space.</dd>
<dt>
<tt>-apcg.corrdim</tt>
</dt>
<dd>the correlation dimensionality of the correlation hyperplane.<br/>Constraint: apcg.corrdim &gt; 0.</dd>
<dt>
<tt>-apcg.dep</tt>
</dt>
<dd>a vector specifying the dependent and independent variables of the correlation hyperplane, where d denotes the dimensionality of the feature space. p_i = 0 specifies an independent variable, any other value of p_i specifies the value of the dependent variable. The number of zero values has to correspond with the specified correlation dimensionality. The values of the dependent variables have to correspond with the specified main and max values. If no vector is specified, the first dataDim - corrDim variables are the dependent variables (the values will be randomized), the last corrDim variables are the independent variables.</dd>
<dt>
<tt>-apcg.dim</tt>
</dt>
<dd>the dimensionality of the feature space.<br/>Constraint: apcg.dim &gt; 0.</dd>
<dt>
<tt>-apcg.jitter</tt>
</dt>
<dd>maximum percentage [0..1] of jitter in each dimension, default is 0.0.<br/>Default: 0.0.<br/>Constraint: apcg.jitter in [0.0, 1.0].</dd>
<dt>
<tt>-apcg.label</tt>
</dt>
<dd>a label specifiying the correlation hyperplane, default is no label.<br/>Default: .</dd>
<dt>
<tt>-apcg.maxima</tt>
</dt>
<dd>a comma separated list of the coordinates of the maximum value in each dimension, default is 1.0 in each dimension</dd>
<dt>
<tt>-apcg.minima</tt>
</dt>
<dd>a comma separated list of the coordinates of the minimum value in each dimension, default is 0.0 in each dimension</dd>
<dt>
<tt>-apcg.number</tt>
</dt>
<dd>the (positive) number of points in the correlation hyperplane.<br/>Constraint: apcg.number &gt; 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>the file to write the generated correlation hyperplane in, if the file already exists, the generated points will be appended to this file.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.SimilarityAdapterLn}</dt>
<dd>
<dl>
<dt>
<tt>-adapter.similarityfunction</tt>
</dt>
<dd>Similarity function to derive the distance between database objects from.<br/>Implementing de.lmu.ifi.dbs.elki.distance.similarityfunction.NormalizedSimilarityFunctionDefault: de.lmu.ifi.dbs.elki.distance.similarityfunction.FractionalSharedNearestNeighborSimilarityFunction.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelTransposingParser}</dt>
<dd>
<dl>
<dt>
<tt>-parser.classLabelIndex</tt>
</dt>
<dd>Index of a class label (may be numeric), counting whitespace separated entries in a line starting with 0 - the corresponding entry will be treated as a label. <br/>Default: -1.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.statistics.DistanceStatisticsWithClasses}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-diststat.sampling</tt>
</dt>
<dd>Enable sampling to reduce runtime from O(2*n*n) to O(n*n)+O(n) at the cost of evenutally having more than the configured number of bins.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.DeLiClu}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-deliclu.minpts</tt>
</dt>
<dd>Threshold for minimum number of points within a cluster.<br/>Constraint: deliclu.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.outlier.GeneralizedLOF}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-genlof.k</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its LOF_SCORE.<br/>Constraint: genlof.k &gt; 1.</dd>
<dt>
<tt>-genlof.reachdistfunction</tt>
</dt>
<dd>Distance function to determine the reachability distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.pca.PCAFilteredAutotuningRunner}</dt>
<dd>
<dl>
<dt>
<tt>-localpca.big</tt>
</dt>
<dd>A constant big value to reset high eigenvalues.<br/>Default: 1.0.<br/>Constraint: localpca.big &gt; 0.</dd>
<dt>
<tt>-localpca.small</tt>
</dt>
<dd>A constant small value to reset low eigenvalues.<br/>Default: 0.0.<br/>Constraint: localpca.small &gt;= 0.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.preprocessing.RangeQueryBasedHiCOPreprocessor}</dt>
<dd>
<dl>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-preprocessor.epsilon</tt>
</dt>
<dd>An epsilon value suitable to the specified distance function.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.SNNClustering}</dt>
<dd>
<dl>
<dt>
<tt>-snn.epsilon</tt>
</dt>
<dd>The minimum SNN density.<br/>Constraint: snn.epsilon &gt; 0.</dd>
<dt>
<tt>-snn.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-SNN-neighborhood of a point.<br/>Constraint: snn.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.outlier.COP}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-cop.k</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its COP_SCORE.<br/>Constraint: cop.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.ERiC}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.KernelBasedLocallyWeightedDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-kernel</tt>
</dt>
<dd>the kernel function which is used to compute the similarity.Default: de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.LinearKernelFunction<br/>Implementing de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.KernelFunctionDefault: de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.LinearKernelFunction.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.arthur.CODECWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considerd, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction</dd>
<dt>
<tt>-dbscan.minpts</tt>
</dt>
<dd> Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: dbscan.minpts &gt; 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to the value of dbscan.minpts<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.outlier.LOCI}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-loci.alpha</tt>
</dt>
<dd>Scaling factor for averaging neighborhood</dd>
<dt>
<tt>-loci.nmin</tt>
</dt>
<dd>Minimum neighborhood size to be considered.<br/>Default: 20.</dd>
<dt>
<tt>-loci.rmax</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.DummyAlgorithm}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.LPNormDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-lpnorm.p</tt>
</dt>
<dd>the degree of the L-P-Norm (positive number)<br/>Constraint: lpnorm.p &gt; 0.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.lisa.MixtureModelOutlierDetection}</dt>
<dd>
<dl>
<dt>
<tt>-mmo.c</tt>
</dt>
<dd>cutoff</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.simon.NaivePatternBased}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.DimensionsSelectingEuclideanDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-distance.dims</tt>
</dt>
<dd>a comma separated array of integer values, where 1 &lt;= d_i &lt;= the dimensionality of the feature space specifying the dimensions to be considered for distance computation. If this parameter is not set, no dimensions will be considered, i.e. the distance between two objects is always 0.<br/>Constraint: all elements of distance.dims &lt; 1.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.result.ResultWriter}</dt>
<dd>
<dl>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-out.gzip</tt>
</dt>
<dd>Enable gzip compression of output files.</dd>
<dt>
<tt>-out.silentoverwrite</tt>
</dt>
<dd>Silently overwrite output files.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.parser.FloatVectorLabelParser}</dt>
<dd>
<dl>
<dt>
<tt>-parser.classLabelIndex</tt>
</dt>
<dd>Index of a class label (may be numeric), counting whitespace separated entries in a line starting with 0 - the corresponding entry will be treated as a label. <br/>Default: -1.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.tobias.rknnjoin.structures.artree.ARStarTree}</dt>
<dd>
<dl>
<dt>
<tt>-spatial.bulk</tt>
</dt>
<dd>flag to specify bulk load (default is no bulk load)</dd>
<dt>
<tt>-spatial.bulkstrategy</tt>
</dt>
<dd>the strategy for bulk load, available strategies are: [MAX_EXTENSION| ZCURVE](default is ZCURVE)<br/>Default: ZCURVE.<br/>Constraint: spatial.bulkstrategy in [MAX_EXTENSION, ZCURVE].</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.elke.algorithm.SUBCLU}</dt>
<dd>
<dl>
<dt>
<tt>-subclu.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Extending de.lmu.ifi.dbs.elki.distance.distancefunction.AbstractDimensionsSelectingDoubleDistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.DimensionsSelectingEuclideanDistanceFunction.</dd>
<dt>
<tt>-subclu.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-subclu.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: subclu.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.NullAlgorithm}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.oldtempdiscarded.DistanceStatistics}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.subspace.CLIQUE}</dt>
<dd>
<dl>
<dt>
<tt>-clique.prune</tt>
</dt>
<dd>Flag to indicate that only subspaces with large coverage (i.e. the fraction of the database that is covered by the dense units) are selected, the rest will be pruned.</dd>
<dt>
<tt>-clique.tau</tt>
</dt>
<dd>The density threshold for the selectivity of a unit, where the selectivity isthe fraction of total feature vectors contained in this unit.<br/>Constraint: clique.tau in (0, 1).</dd>
<dt>
<tt>-clique.xsi</tt>
</dt>
<dd>The number of intervals (units) in each dimension.<br/>Constraint: clique.xsi &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CompositeEigenPairFilter}</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.composite.list</tt>
</dt>
<dd>A comma separated list of the class names of the filters to be used. The specified filters will be applied sequentially in the given order.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.evaluation.holdout.RandomizedCrossValidation}</dt>
<dd>
<dl>
<dt>
<tt>-nfold</tt>
</dt>
<dd>positive number of folds for cross-validation<br/>Default: 10.<br/>Constraint: nfold &gt; 0.</dd>
<dt>
<tt>-seed</tt>
</dt>
<dd>seed for randomized holdout (&gt;0)<br/>Default: 1.<br/>Constraint: seed &gt; 0.0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.CASH}</dt>
<dd>
<dl>
<dt>
<tt>-cash.adjust</tt>
</dt>
<dd>Flag to indicate that an adjustment of the applied heuristic for choosing an interval is performed after an interval is selected.</dd>
<dt>
<tt>-cash.jitter</tt>
</dt>
<dd>The maximum jitter for distance values.<br/>Constraint: cash.jitter &gt; 0.</dd>
<dt>
<tt>-cash.maxlevel</tt>
</dt>
<dd>The maximum level for splitting the hypercube.<br/>Constraint: cash.maxlevel &gt; 0.</dd>
<dt>
<tt>-cash.mindim</tt>
</dt>
<dd>The minimum dimensionality of the subspaces to be found.<br/>Default: 1.<br/>Constraint: cash.mindim &gt; 0.</dd>
<dt>
<tt>-cash.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in a cluster.<br/>Constraint: cash.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.noemi.FIRESold}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.outlier.SOD}</dt>
<dd>
<dl>
<dt>
<tt>-sod.alpha</tt>
</dt>
<dd>The multiplier for the discriminance value for discerning small from large variances.<br/>Default: 1.1.<br/>Constraint: sod.alpha &gt; 0.</dd>
<dt>
<tt>-sod.knn</tt>
</dt>
<dd>The number of shared nearest neighbors to be considered for learning the subspace properties.<br/>Default: 1.<br/>Constraint: sod.knn &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.lisa.ConvexHullOutlierDetection}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.lisa.RandomReferencePointsROS}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-rbo.k</tt>
</dt>
<dd>The number of nearest neighbors</dd>
<dt>
<tt>-rrros.r</tt>
</dt>
<dd>number of partitions on each axis<br/>Default: 3.<br/>Constraint: rrros.r &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.PreDeConWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-projdbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-projdbscan.lambda</tt>
</dt>
<dd>The intrinsic dimensionality of the clusters to find.<br/>Constraint: projdbscan.lambda &gt; 0.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.ERiCDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-ericdf.delta</tt>
</dt>
<dd>Threshold for approximate linear dependency: the strong eigenvectors of q are approximately linear dependent from the strong eigenvectors p if the following condition holds for all stroneg eigenvectors q_i of q (lambda_q &lt; lambda_p): q_i' * M^check_p * q_i &lt;= delta^2.<br/>Default: 0.1.<br/>Constraint: ericdf.delta &gt;= 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.statistics.RankingQualityHistogram}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.lisa.GaussianModelOutlierDetection}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.converter.ArffSparseInstanceToSparseBitVector}</dt>
<dd>
<dl>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.in</tt>
</dt>
<dd>The name of the arff-file to convert.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>the txt-file to write the converted arff-file in.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.lisa.DBOutlierDetection}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-dbod.d</tt>
</dt>
<dd>size of the D-neighborhood</dd>
<dt>
<tt>-dbod.p</tt>
</dt>
<dd>minimum fraction of objects that must be outside the D-neigborhood of an outlier</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.arthur.CoDeC}</dt>
<dd>
<dl>
<dt>
<tt>-codec.classify</tt>
</dt>
<dd>Flag to demand evaluation of the cluster-models as classifier.</dd>
<dt>
<tt>-codec.classlabel</tt>
</dt>
<dd>Class to use for class labels.<br/>Extending de.lmu.ifi.dbs.elki.data.ClassLabel<br/>Known classes (default package de.lmu.ifi.dbs.elki.data.):<br/>-&gt; SimpleClassLabel<br/>-&gt; HierarchicalClassLabel<br/>Default: de.lmu.ifi.dbs.elki.data.HierarchicalClassLabel.</dd>
<dt>
<tt>-codec.clusteringAlgorithm</tt>
</dt>
<dd>Clustering algorithm to use to derive clusters.<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.clustering.ClusteringAlgorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.clustering.):<br/>-&gt; correlation.COPAC<br/>-&gt; DBSCAN<br/>-&gt; EM<br/>-&gt; KMeans<br/>-&gt; SNNClustering<br/>-&gt; correlation.COPAC<br/>-&gt; correlation.FourC<br/>-&gt; correlation.ORCLUS<br/>-&gt; subspace.CLIQUE<br/>-&gt; subspace.PreDeCon<br/>-&gt; subspace.PROCLUS<br/>Default: de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.COPAC.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.COPAC}</dt>
<dd>
<dl>
<dt>
<tt>-copac.partitionAlgorithm</tt>
</dt>
<dd>Clustering algorithm to apply to each partition.<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.clustering.ClusteringAlgorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.clustering.):<br/>-&gt; correlation.COPAC<br/>-&gt; DBSCAN<br/>-&gt; EM<br/>-&gt; KMeans<br/>-&gt; SNNClustering<br/>-&gt; correlation.COPAC<br/>-&gt; correlation.FourC<br/>-&gt; correlation.ORCLUS<br/>-&gt; subspace.CLIQUE<br/>-&gt; subspace.PreDeCon<br/>-&gt; subspace.PROCLUS</dd>
<dt>
<tt>-copac.partitionDB</tt>
</dt>
<dd>Database class for each partition. If this parameter is not set, the databases of the partitions have the same class as the original database.<br/>Implementing de.lmu.ifi.dbs.elki.database.Database<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.):<br/>-&gt; MetricalIndexDatabase<br/>-&gt; SequentialDatabase<br/>-&gt; SpatialIndexDatabase</dd>
<dt>
<tt>-copac.preprocessor</tt>
</dt>
<dd>Preprocessor to derive partition criterion.<br/>Extending de.lmu.ifi.dbs.elki.preprocessing.HiCOPreprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; KnnQueryBasedHiCOPreprocessor<br/>-&gt; RangeQueryBasedHiCOPreprocessor</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.reparser.InputStreamReparser}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.parser</tt>
</dt>
<dd>Parser class to provide a database.<br/>Implementing de.lmu.ifi.dbs.elki.parser.LinebasedParser<br/>Known classes (default package de.lmu.ifi.dbs.elki.parser.):<br/>-&gt; DoubleVectorLabelParser<br/>-&gt; FloatVectorLabelParser<br/>-&gt; DoubleVectorLabelTransposingParser<br/>Default: de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.timeseries.DTWDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-edit.bandSize</tt>
</dt>
<dd>the band size for Edit Distance alignment (positive double value, 0 &lt;= bandSize &lt;= 1)<br/>Default: 0.1.<br/>Constraint: edit.bandSize in [0, 1].</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.data.synthetic.bymodel.GeneratorXMLSpec}</dt>
<dd>
<dl>
<dt>
<tt>-bymodel.randomseed</tt>
</dt>
<dd>The random generator seed.</dd>
<dt>
<tt>-bymodel.sizescale</tt>
</dt>
<dd>Factor for scaling the specified cluster sizes.<br/>Default: 1.0.</dd>
<dt>
<tt>-bymodel.spec</tt>
</dt>
<dd>The generator specification file.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>the file to write the generated data set into, if the file already exists, the generated points will be appended to this file.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser}</dt>
<dd>
<dl>
<dt>
<tt>-parser.classLabelIndex</tt>
</dt>
<dd>Index of a class label (may be numeric), counting whitespace separated entries in a line starting with 0 - the corresponding entry will be treated as a label. <br/>Default: -1.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.index.tree.spatial.rstarvariants.rdknn.RdKNNTree}</dt>
<dd>
<dl>
<dt>
<tt>-rdknn.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.index.tree.spatial.SpatialDistanceFunctionDefault: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-rdknn.k</tt>
</dt>
<dd>positive integer specifying the maximal number k of reverse k nearest neighbors to be supported.<br/>Constraint: rdknn.k &gt; 0.</dd>
<dt>
<tt>-spatial.bulk</tt>
</dt>
<dd>flag to specify bulk load (default is no bulk load)</dd>
<dt>
<tt>-spatial.bulkstrategy</tt>
</dt>
<dd>the strategy for bulk load, available strategies are: [MAX_EXTENSION| ZCURVE](default is ZCURVE)<br/>Default: ZCURVE.<br/>Constraint: spatial.bulkstrategy in [MAX_EXTENSION, ZCURVE].</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.COPACWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considerd, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction</dd>
<dt>
<tt>-dbscan.minpts</tt>
</dt>
<dd> Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: dbscan.minpts &gt; 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to the value of dbscan.minpts<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mktrees.mkmax.MkMaxTree}</dt>
<dd>
<dl>
<dt>
<tt>-mktree.kmax</tt>
</dt>
<dd>Specifies the maximal number k of reverse k nearest neighbors to be supported.<br/>Constraint: mktree.kmax &gt; 0.</dd>
<dt>
<tt>-mtree.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.math.linearalgebra.pca.RelativeEigenPairFilter}</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.relativealpha</tt>
</dt>
<dd>The sensitivity niveau for weak eigenvectors: An eigenvector which is at less than the given share of the statistical average variance is considered weak.<br/>Default: 1.1.<br/>Constraint: pca.filter.relativealpha &gt;= 0.0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.parser.ArffFileParser}</dt>
<dd>
<dl>
<dt>
<tt>-arff.baseparser</tt>
</dt>
<dd>parser getting the input translated from arff format to whitespace separated format<br/>Implementing de.lmu.ifi.dbs.elki.parser.Parser<br/>Known classes (default package de.lmu.ifi.dbs.elki.parser.):<br/>-&gt; BitVectorLabelParser<br/>-&gt; NumberDistanceParser<br/>-&gt; ParameterizationFunctionLabelParser<br/>-&gt; DoubleVectorLabelParser<br/>-&gt; FloatVectorLabelParser<br/>-&gt; DoubleVectorLabelTransposingParser<br/>-&gt; SparseBitVectorLabelParser<br/>Default: de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.KMeans}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-kmeans.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: kmeans.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.lisa.KNNOutlierDetection}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-knno.k</tt>
</dt>
<dd>kth nearest neighbor</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.oldtempdiscarded.MaterializeRankingPreprocessor}</dt>
<dd>
<dl>
<dt>
<tt>-RankingDistanceFunction</tt>
</dt>
<dd>the distance function to obtain the ranking<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-materializeK</tt>
</dt>
<dd>number of nearest neighbors to materialize (at least 1, 0 means full dataset, default)<br/>Default: 0.<br/>Constraint: materializeK &gt;= 0.</dd>
<dt>
<tt>-RankingDistanceFunction</tt>
</dt>
<dd>the distance function to obtain the ranking<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.arthur.SubspaceAggregation}</dt>
<dd>
<dl>
<dt>
<tt>-subspaceagg.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: subspaceagg.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.data.synthetic.AxesParallelCorrelationGenerator}</dt>
<dd>
<dl>
<dt>
<tt>-apcg.corrdim</tt>
</dt>
<dd>the correlation dimensionality of the correlation hyperplane.<br/>Constraint: apcg.corrdim &gt; 0.</dd>
<dt>
<tt>-apcg.dep</tt>
</dt>
<dd>a vector specifying the dependent and independent variables of the correlation hyperplane, where d denotes the dimensionality of the feature space. p_i = 0 specifies an independent variable, any other value of p_i specifies the value of the dependent variable. The number of zero values has to correspond with the specified correlation dimensionality. The values of the dependent variables have to correspond with the specified main and max values. If no vector is specified, the first dataDim - corrDim variables are the dependent variables (the values will be randomized), the last corrDim variables are the independent variables.</dd>
<dt>
<tt>-apcg.dim</tt>
</dt>
<dd>the dimensionality of the feature space.<br/>Constraint: apcg.dim &gt; 0.</dd>
<dt>
<tt>-apcg.jitter</tt>
</dt>
<dd>maximum percentage [0..1] of jitter in each dimension, default is 0.0.<br/>Default: 0.0.<br/>Constraint: apcg.jitter in [0.0, 1.0].</dd>
<dt>
<tt>-apcg.label</tt>
</dt>
<dd>a label specifiying the correlation hyperplane, default is no label.<br/>Default: .</dd>
<dt>
<tt>-apcg.maxima</tt>
</dt>
<dd>a comma separated list of the coordinates of the maximum value in each dimension, default is 1.0 in each dimension</dd>
<dt>
<tt>-apcg.minima</tt>
</dt>
<dd>a comma separated list of the coordinates of the minimum value in each dimension, default is 0.0 in each dimension</dd>
<dt>
<tt>-apcg.number</tt>
</dt>
<dd>the (positive) number of points in the correlation hyperplane.<br/>Constraint: apcg.number &gt; 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>the file to write the generated correlation hyperplane in, if the file already exists, the generated points will be appended to this file.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.classifier.CorrelationBasedClassifier}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PCAFilteredRunner}</dt>
<dd>
<dl>
<dt>
<tt>-localpca.big</tt>
</dt>
<dd>A constant big value to reset high eigenvalues.<br/>Default: 1.0.<br/>Constraint: localpca.big &gt; 0.</dd>
<dt>
<tt>-localpca.small</tt>
</dt>
<dd>A constant small value to reset low eigenvalues.<br/>Default: 0.0.<br/>Constraint: localpca.small &gt;= 0.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
<dt>
<tt>-pca.filter</tt>
</dt>
<dd>Filter class to determine the strong and weak eigenvectors.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.EigenPairFilter<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; FirstNEigenPairFilter<br/>-&gt; LimitEigenPairFilter<br/>-&gt; PercentageEigenPairFilter<br/>-&gt; ProgressiveEigenPairFilter<br/>-&gt; WeakEigenPairFilter<br/>-&gt; RelativeEigenPairFilter<br/>-&gt; SignificantEigenPairFilter<br/>-&gt; CompositeEigenPairFilter<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.FourCWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-pca.filter.absolute</tt>
</dt>
<dd>Flag to mark delta as an absolute value.</dd>
<dt>
<tt>-pca.filter.delta</tt>
</dt>
<dd>The threshold for strong Eigenvalues. If not otherwise specified, delta is a relative value w.r.t. the (absolute) highest Eigenvalues and has to be a double between 0 and 1. To mark delta as an absolute value, use the option -pca.filter.absolute.<br/>Default: 0.01.<br/>Constraints: pca.filter.delta &gt;= 0, pca.filter.delta &lt;= 1.</dd>
<dt>
<tt>-projdbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-projdbscan.lambda</tt>
</dt>
<dd>The intrinsic dimensionality of the clusters to find.<br/>Constraint: projdbscan.lambda &gt; 0.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.noemi.ChengAndChurch}</dt>
<dd>
<dl>
<dt>
<tt>-chengandchurch.alpha</tt>
</dt>
<dd>parameter for multiple node deletion to accelerate the algorithm <br/>Constraint: chengandchurch.alpha &gt;= 1.0.</dd>
<dt>
<tt>-chengandchurch.begin</tt>
</dt>
<dd>lower limit for maskingValues</dd>
<dt>
<tt>-chengandchurch.end</tt>
</dt>
<dd>upper limit for maskingValues</dd>
<dt>
<tt>-chengandchurch.missing</tt>
</dt>
<dd>missing Value in database to be raplaced with maskingValues</dd>
<dt>
<tt>-chengandchurch.multipleAddition</tt>
</dt>
<dd>indicates how many times the algorithm to add Nodes should be performed<br/>Default: 1.<br/>Constraint: chengandchurch.multipleAddition &gt;= 1.</dd>
<dt>
<tt>-chengandchurch.n</tt>
</dt>
<dd>number of biclusters to be found <br/>Default: 1.<br/>Constraint: chengandchurch.n &gt;= 1.</dd>
<dt>
<tt>-chengandchurch.random</tt>
</dt>
<dd>seed for initializing random list for the masking values<br/>Default: 1.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.CLIQUEWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-clique.prune</tt>
</dt>
<dd>Flag to indicate that only subspaces with large coverage (i.e. the fraction of the database that is covered by the dense units) are selected, the rest will be pruned.</dd>
<dt>
<tt>-clique.tau</tt>
</dt>
<dd>The density threshold for the selectivity of a unit, where the selectivity isthe fraction of total feature vectors contained in this unit.<br/>Constraint: clique.tau in (0, 1).</dd>
<dt>
<tt>-clique.xsi</tt>
</dt>
<dd>The number of intervals (units) in each dimension.<br/>Constraint: clique.xsi &gt; 0.</dd>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.elke.algorithm.SUBCLUWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-subclu.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-subclu.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: subclu.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.pca.MultivariateCorrelationOutlierProbability}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-mcop.k</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its MCOP.<br/>Constraint: mcop.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.noemi.FIRES}</dt>
<dd>
<dl>
<dt>
<tt>-fires.baseAlgorithm</tt>
</dt>
<dd>indicates which algorithm is used for calculating the onedimensional base clusters<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.clustering.ClusteringAlgorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.clustering.):<br/>-&gt; correlation.COPAC<br/>-&gt; DBSCAN<br/>-&gt; EM<br/>-&gt; KMeans<br/>-&gt; SNNClustering<br/>-&gt; correlation.COPAC<br/>-&gt; correlation.FourC<br/>-&gt; correlation.ORCLUS<br/>-&gt; subspace.CLIQUE<br/>-&gt; subspace.PreDeCon<br/>-&gt; subspace.PROCLUS</dd>
<dt>
<tt>-fires.intersection</tt>
</dt>
<dd>indicates if the refinement step should be applied upon the union or upon the intersection of base-clusters within a SubspaceClusterApproximation</dd>
<dt>
<tt>-fires.minClu</tt>
</dt>
<dd>minimal size a Best Merge Candidate must have to be cosidered a Best Merge Cluster<br/>Constraint: fires.minClu &gt;= 1.</dd>
<dt>
<tt>-fires.refinementAlgorithm</tt>
</dt>
<dd>indicates which algorithm is used for calculating the onedimensional postprocessing clusters<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.clustering.ClusteringAlgorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.clustering.):<br/>-&gt; correlation.COPAC<br/>-&gt; DBSCAN<br/>-&gt; EM<br/>-&gt; KMeans<br/>-&gt; SNNClustering<br/>-&gt; correlation.COPAC<br/>-&gt; correlation.FourC<br/>-&gt; correlation.ORCLUS<br/>-&gt; subspace.CLIQUE<br/>-&gt; subspace.PreDeCon<br/>-&gt; subspace.PROCLUS</dd>
<dt>
<tt>-fires.thresholdBMC</tt>
</dt>
<dd>threshold for the minimal number of intersections the MSC of a best merge candidate of c (=BMC(c)) must have with MSC(c)<br/>Constraint: fires.thresholdBMC &gt;= 0.</dd>
<dt>
<tt>-fires.thresholdMSC</tt>
</dt>
<dd>threshold for the minimal number of Most Similar Clusters (MSCs)<br/>Constraint: fires.thresholdMSC &gt;= 1.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.index.tree.spatial.rstarvariants.rstar.RStarTree}</dt>
<dd>
<dl>
<dt>
<tt>-spatial.bulk</tt>
</dt>
<dd>flag to specify bulk load (default is no bulk load)</dd>
<dt>
<tt>-spatial.bulkstrategy</tt>
</dt>
<dd>the strategy for bulk load, available strategies are: [MAX_EXTENSION| ZCURVE](default is ZCURVE)<br/>Default: ZCURVE.<br/>Constraint: spatial.bulkstrategy in [MAX_EXTENSION, ZCURVE].</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.arthur.ProjectedDatabase}</dt>
<dd>
<dl>
<dt>
<tt>-projecteddatabase.selecteddimensions</tt>
</dt>
<dd>a comma separated array of integer values d_i, where 1 &lt;= d_i &lt;= the dimensionality of the feature space specifying the dimensions to be considered for projection. If this parameter is not set, no dimensions will be considered, i.e. the projection is a zero-dimensional feature space<br/>Constraint: all elements of projecteddatabase.selecteddimensions &lt; 1.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.outlier.LOF}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-lof.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: lof.cachesize &gt; 0.</dd>
<dt>
<tt>-lof.minpts</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its LOF.<br/>Constraint: lof.minpts &gt; 0.</dd>
<dt>
<tt>-lof.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: lof.pagesize &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.elke.AlgorithmTest}</dt>
<dd>
<dl>
<dt>
<tt>-test.algorithms</tt>
</dt>
<dd>Comma separated list of classnames specifying the algorithms to be run with default parametrization. If this parameter is not set all algorithms as specified in the property file are used.</dd>
<dt>
<tt>-test.in</tt>
</dt>
<dd>The name of the input file to be parsed. This file is used for all specified algorithms as input file.</dd>
<dt>
<tt>-test.out</tt>
</dt>
<dd>Name of the directory to write the results of the specified algorithms in. The result of each algorithm is written into a file/directory with the name of the class of the according algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.normalization.MultiRepresentedObjectNormalization}</dt>
<dd>
<dl>
<dt>
<tt>-normalizations</tt>
</dt>
<dd>A comma separated list of normalizations for each representation. If in one representation no normalization is desired, please use the class 'de.lmu.ifi.dbs.elki.normalization.DummyNormalization' in the list.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.OnlineLOFWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-lof.minpts</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its LOF.<br/>Constraint: lof.minpts &gt; 0.</dd>
<dt>
<tt>-onlinelof.insertions</tt>
</dt>
<dd>The name of the file containing the objects to be inserted.</dd>
<dt>
<tt>-onlinelof.lof</tt>
</dt>
<dd>The name of the file containing the LOFs of the input file.</dd>
<dt>
<tt>-onlinelof.nn</tt>
</dt>
<dd>The name of the file containing the nearest neighbors of the input file.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mktrees.mktab.MkTabTree}</dt>
<dd>
<dl>
<dt>
<tt>-mktree.kmax</tt>
</dt>
<dd>Specifies the maximal number k of reverse k nearest neighbors to be supported.<br/>Constraint: mktree.kmax &gt; 0.</dd>
<dt>
<tt>-mtree.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.oldtempdiscarded.KNNClassifierQuality2}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.database.SpatialIndexDatabase}</dt>
<dd>
<dl>
<dt>
<tt>-spatialindexdb.index</tt>
</dt>
<dd>Spatial index class to use.<br/>Extending de.lmu.ifi.dbs.elki.index.tree.spatial.SpatialIndex<br/>Known classes (default package de.lmu.ifi.dbs.elki.index.tree.spatial.):<br/>-&gt; rstarvariants.deliclu.DeLiCluTree<br/>-&gt; rstarvariants.rstar.RStarTree<br/>-&gt; rstarvariants.rdknn.RdKNNTree</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.preprocessing.KnnQueryBasedHiCOPreprocessor}</dt>
<dd>
<dl>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-hico.pca.distance</tt>
</dt>
<dd>The distance function used to select object for running PCA.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.cache.DiskCacheBasedDoubleDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-distance.matrix</tt>
</dt>
<dd>The name of the file containing the distance matrix.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.PROCLUSWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-projectedclustering.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: projectedclustering.k &gt; 0.</dd>
<dt>
<tt>-projectedclustering.k_i</tt>
</dt>
<dd>The multiplier for the initial number of seeds.<br/>Default: 30.<br/>Constraint: projectedclustering.k_i &gt; 0.</dd>
<dt>
<tt>-projectedclustering.l</tt>
</dt>
<dd>The dimensionality of the clusters to find.<br/>Constraint: projectedclustering.l &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PercentageEigenPairFilter}</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.alpha</tt>
</dt>
<dd>The share (0.0 to 1.0) of variance that needs to be explained by the 'strong' eigenvectors.The filter class will choose the number of strong eigenvectors by this share.<br/>Default: 0.85.<br/>Constraint: pca.filter.alpha in (0.0, 1.0).</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.timeseries.ERPDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-edit.bandSize</tt>
</dt>
<dd>the band size for Edit Distance alignment (positive double value, 0 &lt;= bandSize &lt;= 1)<br/>Default: 0.1.<br/>Constraint: edit.bandSize in [0, 1].</dd>
<dt>
<tt>-erp.g</tt>
</dt>
<dd>the g parameter ERP (positive number)<br/>Default: 0.0.<br/>Constraint: erp.g &gt;= 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mtree.MTree}</dt>
<dd>
<dl>
<dt>
<tt>-mtree.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.timeseries.LCSSDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-lcss.pDelta</tt>
</dt>
<dd>the allowed deviation in x direction for LCSS alignment (positive double value, 0 &lt;= pDelta &lt;= 1)<br/>Default: 0.1.<br/>Constraint: lcss.pDelta in [0, 1].</dd>
<dt>
<tt>-lcss.pEpsilon</tt>
</dt>
<dd>the allowed deviation in y directionfor LCSS alignment (positive double value, 0 &lt;= pEpsilon &lt;= 1)<br/>Default: 0.05.<br/>Constraint: lcss.pEpsilon in [0, 1].</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.math.linearalgebra.pca.WeightedCovarianceMatrixBuilder}</dt>
<dd>
<dl>
<dt>
<tt>-pca.weight</tt>
</dt>
<dd>Weight function to use in weighted PCA.<br/>Implementing de.lmu.ifi.dbs.elki.math.linearalgebra.pca.weightfunctions.WeightFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.weightfunctions.):<br/>-&gt; ConstantWeight<br/>-&gt; ErfcStddevWeight<br/>-&gt; ErfcWeight<br/>-&gt; ExponentialStddevWeight<br/>-&gt; ExponentialWeight<br/>-&gt; GaussStddevWeight<br/>-&gt; GaussWeight<br/>-&gt; InverseLinearWeight<br/>-&gt; InverseProportionalStddevWeight<br/>-&gt; InverseProportionalWeight<br/>-&gt; LinearWeight<br/>-&gt; QuadraticStddevWeight<br/>-&gt; QuadraticWeight<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.weightfunctions.ConstantWeight.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.elke.ica.FastICA}</dt>
<dd>
<dl>
<dt>
<tt>-fastica.app</tt>
</dt>
<dd>the approach to be used, available approaches are: [DEFLATION| SYMMETRIC]. Default: DEFLATION)<br/>Default: experimentalcode.elke.ica.FastICA$Approach.<br/>Constraint: fastica.app in [DEFLATION, SYMMETRIC].</dd>
<dt>
<tt>-fastica.epsilon</tt>
</dt>
<dd>a positive value defining the criterion for convergence of weight vector w_p: if the difference of the values of w_p after two iterations is less than or equal to epsilon. Default: 0.0010<br/>Default: 0.0010.<br/>Constraint: fastica.epsilon &gt; 0.</dd>
<dt>
<tt>-fastica.g</tt>
</dt>
<dd>Contrast function to be used to estimate negentropy.<br/>Implementing experimentalcode.elke.ica.ContrastFunctionDefault: experimentalcode.elke.ica.KurtosisBasedContrastFunction.</dd>
<dt>
<tt>-fastica.ic</tt>
</dt>
<dd>the maximum number of independent components (ics) to be found. The number of ics to be found must be less to or equal than the dimensionality of the feature space.<br/>Constraint: fastica.ic &gt; 0.</dd>
<dt>
<tt>-fastica.maxIter</tt>
</dt>
<dd>the number of maximum iterations. Default: 1000<br/>Default: 1000.<br/>Constraint: fastica.maxIter &gt; 0.</dd>
<dt>
<tt>-fastica.unit</tt>
</dt>
<dd>Flag that indicates that the unit matrix is used as initial weight matrix. If this flag is not set, the initial weight matrix will be generated randomly.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.subspace.PROCLUS}</dt>
<dd>
<dl>
<dt>
<tt>-proclus.mi</tt>
</dt>
<dd>The multiplier for the initial number of medoids.<br/>Default: 10.<br/>Constraint: proclus.mi &gt; 0.</dd>
<dt>
<tt>-projectedclustering.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: projectedclustering.k &gt; 0.</dd>
<dt>
<tt>-projectedclustering.k_i</tt>
</dt>
<dd>The multiplier for the initial number of seeds.<br/>Default: 30.<br/>Constraint: projectedclustering.k_i &gt; 0.</dd>
<dt>
<tt>-projectedclustering.l</tt>
</dt>
<dd>The dimensionality of the clusters to find.<br/>Constraint: projectedclustering.l &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.converter.Arff2Txt}</dt>
<dd>
<dl>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.in</tt>
</dt>
<dd>The name of the arff-file to convert.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>the txt-file to write the converted arff-file in.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.ByLabelClustering}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.lisa.EvolutionaryOutlierDetection}</dt>
<dd>
<dl>
<dt>
<tt>-eod.r</tt>
</dt>
<dd>number of equi-depth ranges</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mktrees.mkapp.MkAppTree}</dt>
<dd>
<dl>
<dt>
<tt>-mkapp.k</tt>
</dt>
<dd>positive integer specifying the maximal number k of reversek nearest neighbors to be supported.<br/>Constraint: mkapp.k &gt; 0.</dd>
<dt>
<tt>-mkapp.nolog</tt>
</dt>
<dd>Flag to indicate that the approximation is done in the ''normal'' space instead of the log-log space (which is default).</dd>
<dt>
<tt>-mkapp.p</tt>
</dt>
<dd>positive integer specifying the order of the polynomial approximation.<br/>Constraint: mkapp.p &gt; 0.</dd>
<dt>
<tt>-mtree.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.math.linearalgebra.pca.ProgressiveEigenPairFilter}</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.progressivealpha</tt>
</dt>
<dd>The share (0.0 to 1.0) of variance that needs to be explained by the 'strong' eigenvectors.The filter class will choose the number of strong eigenvectors by this share.<br/>Default: 0.5.<br/>Constraint: pca.filter.progressivealpha in (0.0, 1.0).</dd>
<dt>
<tt>-pca.filter.weakalpha</tt>
</dt>
<dd>The minimum strength of the statistically expected variance (1/n) share an eigenvector needs to have to be considered 'strong'.<br/>Default: 0.95.<br/>Constraint: pca.filter.weakalpha &gt;= 0.0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.DiSHDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-distancefunction.epsilon</tt>
</dt>
<dd>The maximum distance between two vectors with equal preference vectors before considering them as parallel.<br/>Default: 0.0010.<br/>Constraint: distancefunction.epsilon &gt;= 0.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.tobias.rknnjoin.RkNNJoinTreeTraversal}</dt>
<dd>
<dl>
<dt>
<tt>-dbc2</tt>
</dt>
<dd>Database connection class.<br/>Implementing de.lmu.ifi.dbs.elki.database.connection.DatabaseConnection<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.connection.):<br/>-&gt; FileBasedDatabaseConnection<br/>-&gt; InputStreamDatabaseConnection<br/>-&gt; MultipleFileBasedDatabaseConnection<br/>Default: de.lmu.ifi.dbs.elki.database.connection.FileBasedDatabaseConnection.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.ERiCWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-dbscan.minpts</tt>
</dt>
<dd> Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: dbscan.minpts &gt; 0.</dd>
<dt>
<tt>-ericdf.delta</tt>
</dt>
<dd>Threshold for approximate linear dependency: the strong eigenvectors of q are approximately linear dependent from the strong eigenvectors p if the following condition holds for all stroneg eigenvectors q_i of q (lambda_q &lt; lambda_p): q_i' * M^check_p * q_i &lt;= delta^2.<br/>Default: 0.1.<br/>Constraint: ericdf.delta &gt;= 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-hicopreprocessor.k</tt>
</dt>
<dd>The number of nearest neighbors considered in the PCA. If this parameter is not set, k ist set to the value of dbscan.minpts.<br/>Constraint: hicopreprocessor.k &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.index.tree.spatial.rstarvariants.flat.FlatRStarTree}</dt>
<dd>
<dl>
<dt>
<tt>-spatial.bulk</tt>
</dt>
<dd>flag to specify bulk load (default is no bulk load)</dd>
<dt>
<tt>-spatial.bulkstrategy</tt>
</dt>
<dd>the strategy for bulk load, available strategies are: [MAX_EXTENSION| ZCURVE](default is ZCURVE)<br/>Default: ZCURVE.<br/>Constraint: spatial.bulkstrategy in [MAX_EXTENSION, ZCURVE].</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.preprocessing.KernelFourCPreprocessor}</dt>
<dd>
<dl>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.<br/>Default: the maximum radius of the neighborhood to be considered, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction.</dd>
<dt>
<tt>-pca.filter.absolute</tt>
</dt>
<dd>Flag to mark delta as an absolute value.</dd>
<dt>
<tt>-pca.filter.delta</tt>
</dt>
<dd>The threshold for strong Eigenvalues. If not otherwise specified, delta is a relative value w.r.t. the (absolute) highest Eigenvalues and has to be a double between 0 and 1. To mark delta as an absolute value, use the option -pca.filter.absolute.<br/>Default: 0.1.<br/>Constraint: pca.filter.delta &gt;= 0.</dd>
<dt>
<tt>-projdbscan.distancefunction</tt>
</dt>
<dd>Distance function to determine the neighbors for variance analysis.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.database.connection.MultipleFileBasedDatabaseConnection}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.classLabelClass</tt>
</dt>
<dd>Class label class to use.<br/>Extending de.lmu.ifi.dbs.elki.data.ClassLabel<br/>Known classes (default package de.lmu.ifi.dbs.elki.data.):<br/>-&gt; SimpleClassLabel<br/>-&gt; HierarchicalClassLabel<br/>Default: de.lmu.ifi.dbs.elki.data.SimpleClassLabel.</dd>
<dt>
<tt>-dbc.classLabelIndex</tt>
</dt>
<dd>The index of the label to be used as class label.<br/>Constraint: dbc.classLabelIndex &gt;= 0.</dd>
<dt>
<tt>-dbc.database</tt>
</dt>
<dd>Database class to be provided by the parse method.<br/>Implementing de.lmu.ifi.dbs.elki.database.Database<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.):<br/>-&gt; MetricalIndexDatabase<br/>-&gt; SequentialDatabase<br/>-&gt; SpatialIndexDatabase<br/>Default: de.lmu.ifi.dbs.elki.database.SequentialDatabase.</dd>
<dt>
<tt>-dbc.externalIDIndex</tt>
</dt>
<dd>The index of the label to be used as an external id.<br/>Constraint: dbc.externalIDIndex &gt;= 0.</dd>
<dt>
<tt>-multipledbc.in</tt>
</dt>
<dd>A comma separated list of the names of the input files to be parsed.</dd>
<dt>
<tt>-multipledbc.parsers</tt>
</dt>
<dd>Comma separated list of classnames specifying the parsers to provide a database. If this parameter is not set, de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser is used as parser for all input files.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.oldtempdiscarded.DistanceStatisticsWithClasses}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.ORCLUS}</dt>
<dd>
<dl>
<dt>
<tt>-orclus.alpha</tt>
</dt>
<dd>The factor for reducing the number of current clusters in each iteration.<br/>Default: 0.5.<br/>Constraint: orclus.alpha in (0, 1].</dd>
<dt>
<tt>-projectedclustering.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: projectedclustering.k &gt; 0.</dd>
<dt>
<tt>-projectedclustering.k_i</tt>
</dt>
<dd>The multiplier for the initial number of seeds.<br/>Default: 30.<br/>Constraint: projectedclustering.k_i &gt; 0.</dd>
<dt>
<tt>-projectedclustering.l</tt>
</dt>
<dd>The dimensionality of the clusters to find.<br/>Constraint: projectedclustering.l &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.TrivialAllInOne}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.DBSCANWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considerd, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction<br/>Default: 1.0.</dd>
<dt>
<tt>-dbscan.minpts</tt>
</dt>
<dd> Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Default: 10.<br/>Constraint: dbscan.minpts &gt; 0.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.lisa.EMOutlierDetection}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.noemi.MaPle}</dt>
<dd>
<dl>
<dt>
<tt>-maple.nc</tt>
</dt>
<dd>indicates the minimum columnsize of the resulting biclusters<br/>Constraint: maple.nc &gt;= 1.</dd>
<dt>
<tt>-maple.nr</tt>
</dt>
<dd>indicates the minimum rowsize of the resulting biclusters<br/>Constraint: maple.nr &gt;= 1.</dd>
<dt>
<tt>-maple.sigma</tt>
</dt>
<dd>treshhold value to determine the maximal acceptable score of a bicluster<br/>Constraint: maple.sigma &gt;= 0.0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.PCABasedCorrelationDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-pcabasedcorrelationdf.delta</tt>
</dt>
<dd>Threshold of a distance between a vector q and a given space that indicates that q adds a new dimension to the space.<br/>Default: 0.25.<br/>Constraint: pcabasedcorrelationdf.delta &gt;= 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.KernelFourC}</dt>
<dd>
<dl>
<dt>
<tt>-projdbscan.distancefunction</tt>
</dt>
<dd>Distance function to determine the neighbors for variance analysis.<br/>Extending de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction</dd>
<dt>
<tt>-projdbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-projdbscan.lambda</tt>
</dt>
<dd>The intrinsic dimensionality of the clusters to find.<br/>Constraint: projdbscan.lambda &gt; 0.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.HiSCWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-hisc.alpha</tt>
</dt>
<dd>a double between 0 and 1 specifying the maximum absolute variance along a coordinate axis.<br/>Default: 0.01.<br/>Constraint: hisc.alpha in (0.0, 1.0).</dd>
<dt>
<tt>-hisc.k</tt>
</dt>
<dd>a positive integer specifying the number of nearest neighbors considered to determine the preference vector. If this value is not defined, k ist set to three times of the dimensionality of the database objects.<br/>Constraint: hisc.k &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.FooKernelFunction}</dt>
<dd>
<dl>
<dt>
<tt>-fookernel.max_degree</tt>
</dt>
<dd>The max degree of theFooKernelFunction. Default: 2<br/>Default: 2.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.CASHWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-cash.maxlevel</tt>
</dt>
<dd>The maximum level for splitting the hypercube.<br/>Constraint: cash.maxlevel &gt; 0.</dd>
<dt>
<tt>-cash.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in a cluster.<br/>Constraint: cash.minpts &gt; 0.</dd>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.outlier.OnlineLOF}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-lof.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: lof.cachesize &gt; 0.</dd>
<dt>
<tt>-lof.minpts</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its LOF.<br/>Constraint: lof.minpts &gt; 0.</dd>
<dt>
<tt>-lof.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: lof.pagesize &gt; 0.</dd>
<dt>
<tt>-onlinelof.insertions</tt>
</dt>
<dd>The name of the file containing the objects to be inserted.</dd>
<dt>
<tt>-onlinelof.lof</tt>
</dt>
<dd>The name of the file containing the LOFs of the input file.</dd>
<dt>
<tt>-onlinelof.nn</tt>
</dt>
<dd>The name of the file containing the nearest neighbors of the input file.</dd>
<dt>
<tt>-onlinelof.parser</tt>
</dt>
<dd>Parser to parse the insertion and/or deletion files.<br/>Implementing de.lmu.ifi.dbs.elki.parser.Parser<br/>Known classes (default package de.lmu.ifi.dbs.elki.parser.):<br/>-&gt; BitVectorLabelParser<br/>-&gt; NumberDistanceParser<br/>-&gt; ParameterizationFunctionLabelParser<br/>-&gt; DoubleVectorLabelParser<br/>-&gt; FloatVectorLabelParser<br/>-&gt; DoubleVectorLabelTransposingParser<br/>-&gt; SparseBitVectorLabelParser<br/>Default: de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.HiSCDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-distancefunction.epsilon</tt>
</dt>
<dd>The maximum distance between two vectors with equal preference vectors before considering them as parallel.<br/>Default: 0.0010.<br/>Constraint: distancefunction.epsilon &gt;= 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.EM}</dt>
<dd>
<dl>
<dt>
<tt>-em.delta</tt>
</dt>
<dd>The termination criterion for maximization of E(M): E(M) - E(M') &lt; em.delta<br/>Default: 0.0.<br/>Constraint: em.delta &gt;= 0.0.</dd>
<dt>
<tt>-em.k</tt>
</dt>
<dd>The number of clusters to find.<br/>Constraint: em.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.DependencyDerivatorWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.outlier.ABOD}</dt>
<dd>
<dl>
<dt>
<tt>-abod.fast</tt>
</dt>
<dd>Flag to indicate that the algorithm should run the fast/approximative version.</dd>
<dt>
<tt>-abod.k</tt>
</dt>
<dd>Parameter k for kNN queries.<br/>Default: 30.<br/>Constraint: abod.k &gt;= 1.</dd>
<dt>
<tt>-abod.kernelfunction</tt>
</dt>
<dd>Kernel function to use.<br/>Implementing de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.KernelFunctionDefault: de.lmu.ifi.dbs.elki.distance.similarityfunction.kernel.PolynomialKernelFunction.</dd>
<dt>
<tt>-abod.samplesize</tt>
</dt>
<dd>Sample size to use in fast mode.<br/>Constraint: abod.samplesize &gt;= 1.</dd>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.evaluation.holdout.DisjointCrossValidation}</dt>
<dd>
<dl>
<dt>
<tt>-nfold</tt>
</dt>
<dd>positive number of folds for cross-validation<br/>Default: 10.<br/>Constraint: nfold &gt; 0.</dd>
<dt>
<tt>-seed</tt>
</dt>
<dd>seed for randomized holdout (&gt;0)<br/>Default: 1.<br/>Constraint: seed &gt; 0.0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.DimensionSelectingDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-dim</tt>
</dt>
<dd>an integer between 1 and the dimensionality of the feature space 1 specifying the dimension to be considered for distance computation.<br/>Constraint: dim &gt;= 1.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.arthur.LoggingTester}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.evaluation.procedure.ClassifierEvaluationProcedure}</dt>
<dd>
<dl>
<dt>
<tt>-classifier.holdout</tt>
</dt>
<dd>Holdout class used in evaluation.<br/>Implementing de.lmu.ifi.dbs.elki.evaluation.holdout.Holdout<br/>Known classes (default package de.lmu.ifi.dbs.elki.evaluation.holdout.):<br/>-&gt; DisjointCrossValidation<br/>-&gt; LeaveOneOut<br/>-&gt; ProvidedTestSet<br/>-&gt; RandomizedCrossValidation<br/>-&gt; StratifiedCrossValidation<br/>Default: de.lmu.ifi.dbs.elki.evaluation.holdout.StratifiedCrossValidation.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.oldtempdiscarded.KNNClassifierQuality}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.noemi.FIRESusingDBSCAN}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.APRIORI}</dt>
<dd>
<dl>
<dt>
<tt>-apriori.minfreq</tt>
</dt>
<dd>Threshold for minimum frequency as percentage value (alternatively to parameter apriori.minsupp).<br/>Constraint: apriori.minfreq in [0, 1].</dd>
<dt>
<tt>-apriori.minsupp</tt>
</dt>
<dd>Threshold for minimum support as minimally required number of transactions (alternatively to parameter apriori.minfreq - setting apriori.minsupp is slightly preferable over setting apriori.minfreq in terms of efficiency).<br/>Constraint: apriori.minsupp &gt;= 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.math.linearalgebra.pca.SignificantEigenPairFilter}</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.weakalpha</tt>
</dt>
<dd>The minimum strength of the statistically expected variance (1/n) share an eigenvector needs to have to be considered 'strong'.<br/>Default: 0.0.<br/>Constraint: pca.filter.weakalpha &gt;= 0.0.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.pca.OOScaR}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-ooscar.inneralg</tt>
</dt>
<dd>Inner algorithm to run.<br/>Extending de.lmu.ifi.dbs.elki.algorithm.DistanceBasedAlgorithmDefault: de.lmu.ifi.dbs.elki.algorithm.clustering.DBSCAN.</dd>
<dt>
<tt>-ooscar.innerdistance</tt>
</dt>
<dd>Distance function for the inner algorithm.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: experimentalcode.erich.pca.OrientationDistanceFunction.</dd>
<dt>
<tt>-ooscar.k</tt>
</dt>
<dd>The number of nearest neighbors of an object to be considered for computing its COP.<br/>Constraint: ooscar.k &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.subspace.DiSH}</dt>
<dd>
<dl>
<dt>
<tt>-dish.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered in each dimension for determination of the preference vector.<br/>Default: 0.0010.<br/>Constraint: dish.epsilon &gt;= 0.</dd>
<dt>
<tt>-dish.mu</tt>
</dt>
<dd>The minimum number of points as a smoothing factor to avoid the single-link-effekt.<br/>Default: 1.<br/>Constraint: dish.mu &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.DBSCAN}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-dbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-dbscan.minpts</tt>
</dt>
<dd> Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: dbscan.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.KNNDistanceOrder}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-knndistanceorder.k</tt>
</dt>
<dd>Specifies the distance of the k-distant object to be assessed.<br/>Default: 1.<br/>Constraint: knndistanceorder.k &gt; 0.</dd>
<dt>
<tt>-knndistanceorder.percentage</tt>
</dt>
<dd>The average percentage of distances randomly choosen to be provided in the result.<br/>Default: 1.0.<br/>Constraint: knndistanceorder.percentage in (0, 1].</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.KDDTask}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm</tt>
</dt>
<dd>Algorithm to run.<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.Algorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.):<br/>-&gt; outlier.COP<br/>-&gt; outlier.GeneralizedLOF<br/>-&gt; outlier.LOF<br/>-&gt; APRIORI<br/>-&gt; DependencyDerivator<br/>-&gt; KNNDistanceOrder<br/>-&gt; KNNJoin<br/>-&gt; classifier.CorrelationBasedClassifier<br/>-&gt; classifier.KNNClassifier<br/>-&gt; classifier.PriorProbabilityClassifier<br/>-&gt; clustering.DBSCAN<br/>-&gt; clustering.DeLiClu<br/>-&gt; clustering.EM<br/>-&gt; clustering.KMeans<br/>-&gt; clustering.OPTICS<br/>-&gt; clustering.SLINK<br/>-&gt; clustering.SNNClustering<br/>-&gt; clustering.ByLabelClustering<br/>-&gt; clustering.TrivialAllInOne<br/>-&gt; clustering.TrivialAllNoise<br/>-&gt; clustering.correlation.CASH<br/>-&gt; clustering.correlation.COPAC<br/>-&gt; clustering.correlation.ERiC<br/>-&gt; clustering.correlation.FourC<br/>-&gt; clustering.correlation.ORCLUS<br/>-&gt; clustering.subspace.CLIQUE<br/>-&gt; clustering.subspace.DiSH<br/>-&gt; clustering.subspace.PreDeCon<br/>-&gt; clustering.subspace.PROCLUS</dd>
<dt>
<tt>-dbc</tt>
</dt>
<dd>Database connection class.<br/>Implementing de.lmu.ifi.dbs.elki.database.connection.DatabaseConnection<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.connection.):<br/>-&gt; FileBasedDatabaseConnection<br/>-&gt; InputStreamDatabaseConnection<br/>-&gt; MultipleFileBasedDatabaseConnection<br/>Default: de.lmu.ifi.dbs.elki.database.connection.FileBasedDatabaseConnection.</dd>
<dt>
<tt>-description</tt>
</dt>
<dd>Class to obtain a description of. Causes immediate stop of the program.<br/>Implementing de.lmu.ifi.dbs.elki.utilities.optionhandling.Parameterizable</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-norm</tt>
</dt>
<dd>Normalization class in order to normalize values in the database.<br/>Implementing de.lmu.ifi.dbs.elki.normalization.Normalization<br/>Known classes (default package de.lmu.ifi.dbs.elki.normalization.):<br/>-&gt; AttributeWiseRealVectorNormalization<br/>-&gt; DummyNormalization<br/>-&gt; MultiRepresentedObjectNormalization</dd>
<dt>
<tt>-normUndo</tt>
</dt>
<dd>Revert normalization result to original values - invalid option if no normalization has been performed.</dd>
<dt>
<tt>-resulthandler</tt>
</dt>
<dd>Result handler class.<br/>Implementing de.lmu.ifi.dbs.elki.result.ResultHandler<br/>Known classes (default package de.lmu.ifi.dbs.elki.result.):<br/>-&gt; ResultWriter<br/>-&gt; DiscardResultHandler<br/>Default: de.lmu.ifi.dbs.elki.result.ResultWriter.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.arthur.biclustering.NaivePatternBased}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.evaluation.holdout.ProvidedTestSet}</dt>
<dd>
<dl>
<dt>
<tt>-testdbc</tt>
</dt>
<dd>Database connection to testset database.<br/>Implementing de.lmu.ifi.dbs.elki.database.connection.DatabaseConnection<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.connection.):<br/>-&gt; FileBasedDatabaseConnection<br/>-&gt; InputStreamDatabaseConnection<br/>-&gt; MultipleFileBasedDatabaseConnection<br/>Default: de.lmu.ifi.dbs.elki.database.connection.FileBasedDatabaseConnection.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.preprocessing.PreprocessorHandler}</dt>
<dd>
<dl>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>The Classname of the preprocessor to determine the neighbors of the objects.<br/>Extending de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessorDefault: de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>The Classname of the preprocessor to determine the neighbors of the objects.<br/>Extending de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessorDefault: de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>Preprocessor class to determine the correlation dimension of each object.<br/>Extending de.lmu.ifi.dbs.elki.preprocessing.HiCOPreprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; KnnQueryBasedHiCOPreprocessor<br/>-&gt; RangeQueryBasedHiCOPreprocessor<br/>Default: de.lmu.ifi.dbs.elki.preprocessing.KnnQueryBasedHiCOPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>Preprocessor class to determine the correlation dimension of each object.<br/>Implementing de.lmu.ifi.dbs.elki.preprocessing.Preprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; DiSHPreprocessor<br/>-&gt; FourCPreprocessor<br/>-&gt; HiSCPreprocessor<br/>-&gt; KnnQueryBasedHiCOPreprocessor<br/>-&gt; PreDeConPreprocessor<br/>-&gt; RangeQueryBasedHiCOPreprocessor<br/>Default: de.lmu.ifi.dbs.elki.preprocessing.KnnQueryBasedHiCOPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>Preprocessor class to determine the correlation dimension of each object.<br/>Implementing de.lmu.ifi.dbs.elki.preprocessing.Preprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; DiSHPreprocessor<br/>-&gt; FourCPreprocessor<br/>-&gt; HiSCPreprocessor<br/>-&gt; KnnQueryBasedHiCOPreprocessor<br/>-&gt; PreDeConPreprocessor<br/>-&gt; RangeQueryBasedHiCOPreprocessor<br/>Default: de.lmu.ifi.dbs.elki.preprocessing.KnnQueryBasedHiCOPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>Preprocessor class to determine the correlation dimension of each object.<br/>Implementing de.lmu.ifi.dbs.elki.preprocessing.Preprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; DiSHPreprocessor<br/>-&gt; FourCPreprocessor<br/>-&gt; HiSCPreprocessor<br/>-&gt; KnnQueryBasedHiCOPreprocessor<br/>-&gt; PreDeConPreprocessor<br/>-&gt; RangeQueryBasedHiCOPreprocessor<br/>Default: de.lmu.ifi.dbs.elki.preprocessing.KnnQueryBasedHiCOPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>Preprocessor class to determine the preference vector of each object.<br/>Implementing de.lmu.ifi.dbs.elki.preprocessing.PreferenceVectorPreprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; DiSHPreprocessor<br/>-&gt; HiSCPreprocessor<br/>Default: de.lmu.ifi.dbs.elki.preprocessing.HiSCPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>Preprocessor class to determine the correlation dimension of each object.<br/>Implementing de.lmu.ifi.dbs.elki.preprocessing.Preprocessor<br/>Known classes (default package de.lmu.ifi.dbs.elki.preprocessing.):<br/>-&gt; DiSHPreprocessor<br/>-&gt; FourCPreprocessor<br/>-&gt; HiSCPreprocessor<br/>-&gt; KnnQueryBasedHiCOPreprocessor<br/>-&gt; PreDeConPreprocessor<br/>-&gt; RangeQueryBasedHiCOPreprocessor<br/>Default: de.lmu.ifi.dbs.elki.preprocessing.KnnQueryBasedHiCOPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>The Classname of the preprocessor to determine the neighbors of the objects.<br/>Extending de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessorDefault: de.lmu.ifi.dbs.elki.preprocessing.SharedNearestNeighborsPreprocessor.</dd>
<dt>
<tt>-preprocessorhandler.omitPreprocessing</tt>
</dt>
<dd>Flag to omit (a new) preprocessing if for each object the association has already been set.</dd>
<dt>
<tt>-preprocessorhandler.preprocessor</tt>
</dt>
<dd>The Classname of the preprocessor to determine the neighbors of the objects.<br/>Extending experimentalcode.erich.oldtempdiscarded.MaterializeRankingPreprocessorDefault: experimentalcode.erich.oldtempdiscarded.MaterializeRankingPreprocessor.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.database.connection.InputStreamDatabaseConnection}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.classLabelClass</tt>
</dt>
<dd>Class label class to use.<br/>Extending de.lmu.ifi.dbs.elki.data.ClassLabel<br/>Known classes (default package de.lmu.ifi.dbs.elki.data.):<br/>-&gt; SimpleClassLabel<br/>-&gt; HierarchicalClassLabel<br/>Default: de.lmu.ifi.dbs.elki.data.SimpleClassLabel.</dd>
<dt>
<tt>-dbc.classLabelIndex</tt>
</dt>
<dd>The index of the label to be used as class label.<br/>Constraint: dbc.classLabelIndex &gt;= 0.</dd>
<dt>
<tt>-dbc.database</tt>
</dt>
<dd>Database class to be provided by the parse method.<br/>Implementing de.lmu.ifi.dbs.elki.database.Database<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.):<br/>-&gt; MetricalIndexDatabase<br/>-&gt; SequentialDatabase<br/>-&gt; SpatialIndexDatabase<br/>Default: de.lmu.ifi.dbs.elki.database.SequentialDatabase.</dd>
<dt>
<tt>-dbc.externalIDIndex</tt>
</dt>
<dd>The index of the label to be used as an external id.<br/>Constraint: dbc.externalIDIndex &gt;= 0.</dd>
<dt>
<tt>-dbc.parser</tt>
</dt>
<dd>Parser to provide the database.<br/>Implementing de.lmu.ifi.dbs.elki.parser.Parser<br/>Known classes (default package de.lmu.ifi.dbs.elki.parser.):<br/>-&gt; BitVectorLabelParser<br/>-&gt; NumberDistanceParser<br/>-&gt; ParameterizationFunctionLabelParser<br/>-&gt; DoubleVectorLabelParser<br/>-&gt; FloatVectorLabelParser<br/>-&gt; DoubleVectorLabelTransposingParser<br/>-&gt; SparseBitVectorLabelParser<br/>Default: de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.normalization.AttributeWiseRealVectorNormalization}</dt>
<dd>
<dl>
<dt>
<tt>-normalize.max</tt>
</dt>
<dd>a comma separated concatenation of the maximum values in each dimension that are mapped to 1 If no value is specified, the maximum value of the attribute range in this dimension will be taken.</dd>
<dt>
<tt>-normalize.min</tt>
</dt>
<dd>a comma separated concatenation of the minimum values in each dimension that are mapped to 0. If no value is specified, the minimum value of the attribute range in this dimension will be taken.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.timeseries.EDRDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-edit.bandSize</tt>
</dt>
<dd>the band size for Edit Distance alignment (positive double value, 0 &lt;= bandSize &lt;= 1)<br/>Default: 0.1.<br/>Constraint: edit.bandSize in [0, 1].</dd>
<dt>
<tt>-edr.delta</tt>
</dt>
<dd>the delta parameter (similarity threshold) for EDR (positive number)<br/>Default: 1.0.<br/>Constraint: edr.delta &gt;= 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.database.connection.FileBasedDatabaseConnection}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.classLabelClass</tt>
</dt>
<dd>Class label class to use.<br/>Extending de.lmu.ifi.dbs.elki.data.ClassLabel<br/>Known classes (default package de.lmu.ifi.dbs.elki.data.):<br/>-&gt; SimpleClassLabel<br/>-&gt; HierarchicalClassLabel<br/>Default: de.lmu.ifi.dbs.elki.data.SimpleClassLabel.</dd>
<dt>
<tt>-dbc.classLabelIndex</tt>
</dt>
<dd>The index of the label to be used as class label.<br/>Constraint: dbc.classLabelIndex &gt;= 0.</dd>
<dt>
<tt>-dbc.database</tt>
</dt>
<dd>Database class to be provided by the parse method.<br/>Implementing de.lmu.ifi.dbs.elki.database.Database<br/>Known classes (default package de.lmu.ifi.dbs.elki.database.):<br/>-&gt; MetricalIndexDatabase<br/>-&gt; SequentialDatabase<br/>-&gt; SpatialIndexDatabase<br/>Default: de.lmu.ifi.dbs.elki.database.SequentialDatabase.</dd>
<dt>
<tt>-dbc.externalIDIndex</tt>
</dt>
<dd>The index of the label to be used as an external id.<br/>Constraint: dbc.externalIDIndex &gt;= 0.</dd>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-dbc.parser</tt>
</dt>
<dd>Parser to provide the database.<br/>Implementing de.lmu.ifi.dbs.elki.parser.Parser<br/>Known classes (default package de.lmu.ifi.dbs.elki.parser.):<br/>-&gt; BitVectorLabelParser<br/>-&gt; NumberDistanceParser<br/>-&gt; ParameterizationFunctionLabelParser<br/>-&gt; DoubleVectorLabelParser<br/>-&gt; FloatVectorLabelParser<br/>-&gt; DoubleVectorLabelTransposingParser<br/>-&gt; SparseBitVectorLabelParser<br/>Default: de.lmu.ifi.dbs.elki.parser.DoubleVectorLabelParser.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.cache.LoadDistanceResultIntoDiskCache}</dt>
<dd>
<dl>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-loader.diskcache</tt>
</dt>
<dd>File name of the disk cache to create.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.erich.ReparseAndVisualize}</dt>
<dd>
<dl>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-resulthandler</tt>
</dt>
<dd>Result handler class.<br/>Implementing de.lmu.ifi.dbs.elki.result.ResultHandler<br/>Known classes (default package de.lmu.ifi.dbs.elki.result.):<br/>-&gt; ResultWriter<br/>-&gt; DiscardResultHandler<br/>Default: experimentalcode.erich.ResultVisualizeScatterplot.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.correlation.FourC}</dt>
<dd>
<dl>
<dt>
<tt>-projdbscan.distancefunction</tt>
</dt>
<dd>Distance function to determine the neighbors for variance analysis.<br/>Extending de.lmu.ifi.dbs.elki.distance.distancefunction.LocallyWeightedDistanceFunction</dd>
<dt>
<tt>-projdbscan.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered.</dd>
<dt>
<tt>-projdbscan.lambda</tt>
</dt>
<dd>The intrinsic dimensionality of the clusters to find.<br/>Constraint: projdbscan.lambda &gt; 0.</dd>
<dt>
<tt>-projdbscan.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: projdbscan.minpts &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.math.linearalgebra.pca.PCARunner}</dt>
<dd>
<dl>
<dt>
<tt>-pca.covariance</tt>
</dt>
<dd>Class used to compute the covariance matrix.<br/>Extending de.lmu.ifi.dbs.elki.math.linearalgebra.pca.CovarianceMatrixBuilder<br/>Known classes (default package de.lmu.ifi.dbs.elki.math.linearalgebra.pca.):<br/>-&gt; StandardCovarianceMatrixBuilder<br/>-&gt; KernelCovarianceMatrixBuilder<br/>-&gt; WeightedCovarianceMatrixBuilder<br/>Default: de.lmu.ifi.dbs.elki.math.linearalgebra.pca.StandardCovarianceMatrixBuilder.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.TransposedViewWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out.gnu</tt>
</dt>
<dd>file to write the gnuplot script in.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-wrapper.in</tt>
</dt>
<dd>The name of the input file.</dd>
<dt>
<tt>-wrapper.out</tt>
</dt>
<dd>The name of the output file.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.noemi.PClustering}</dt>
<dd>
<dl>
<dt>
<tt>-pclustering.nc</tt>
</dt>
<dd>indicates the minimum columnsize of the resulting biclusters<br/>Constraint: pclustering.nc &gt;= 1.</dd>
<dt>
<tt>-pclustering.nr</tt>
</dt>
<dd>indicates the minimum rowsize of the resulting biclusters<br/>Constraint: pclustering.nr &gt;= 1.</dd>
<dt>
<tt>-pclustering.sigma</tt>
</dt>
<dd>treshhold value to determine the maximal acceptable score of a bicluster<br/>Constraint: pclustering.sigma &gt;= 0.0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.lisa.KNNIntegralOutlierDetection}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-knnio.k</tt>
</dt>
<dd>kth nearest neighbor</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.math.linearalgebra.pca.FirstNEigenPairFilter}</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.n</tt>
</dt>
<dd>The number of strong eigenvectors: n eigenvectors with the n highesteigenvalues are marked as strong eigenvectors.<br/>Constraint: pca.filter.n &gt;= 0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.OPTICSWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-optics.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered, must be suitable to de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction</dd>
<dt>
<tt>-optics.minpts</tt>
</dt>
<dd>Threshold for minimum number of points in the epsilon-neighborhood of a point.<br/>Constraint: optics.minpts &gt; 0.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.MaterializeDistances}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.database.MetricalIndexDatabase}</dt>
<dd>
<dl>
<dt>
<tt>-metricalindexdb.index</tt>
</dt>
<dd>Metrical index class to use.<br/>Extending de.lmu.ifi.dbs.elki.index.tree.metrical.MetricalIndex<br/>Known classes (default package de.lmu.ifi.dbs.elki.index.tree.metrical.):<br/>-&gt; mtreevariants.mtree.MTree<br/>-&gt; mtreevariants.mktrees.mkcop.MkCoPTree<br/>-&gt; mtreevariants.mktrees.mkmax.MkMaxTree<br/>-&gt; mtreevariants.mktrees.mktab.MkTabTree</dd>
</dl>
</dd>
<dt>{@link experimentalcode.noemi.FIRES2}</dt>
<dd>
<dl>
<dt>
<tt>-fires.baseAlgorithm</tt>
</dt>
<dd>indicates which algorithm is used for calculating the onedimensional base clusters<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.clustering.ClusteringAlgorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.clustering.):<br/>-&gt; correlation.COPAC<br/>-&gt; DBSCAN<br/>-&gt; EM<br/>-&gt; KMeans<br/>-&gt; SNNClustering<br/>-&gt; correlation.COPAC<br/>-&gt; correlation.FourC<br/>-&gt; correlation.ORCLUS<br/>-&gt; subspace.CLIQUE<br/>-&gt; subspace.PreDeCon<br/>-&gt; subspace.PROCLUS</dd>
<dt>
<tt>-fires.minClu</tt>
</dt>
<dd>minimal size a Best Merge Candidate must have to be cosidered a Best Merge Cluster<br/>Constraint: fires.minClu &gt;= 1.</dd>
<dt>
<tt>-fires.refinementAlgorithm</tt>
</dt>
<dd>indicates which algorithm is used for calculating the onedimensional postprocessing clusters<br/>Implementing de.lmu.ifi.dbs.elki.algorithm.clustering.ClusteringAlgorithm<br/>Known classes (default package de.lmu.ifi.dbs.elki.algorithm.clustering.):<br/>-&gt; correlation.COPAC<br/>-&gt; DBSCAN<br/>-&gt; EM<br/>-&gt; KMeans<br/>-&gt; SNNClustering<br/>-&gt; correlation.COPAC<br/>-&gt; correlation.FourC<br/>-&gt; correlation.ORCLUS<br/>-&gt; subspace.CLIQUE<br/>-&gt; subspace.PreDeCon<br/>-&gt; subspace.PROCLUS</dd>
<dt>
<tt>-fires.thresholdBMC</tt>
</dt>
<dd>threshold for the minimal number of intersections the MSC of a best merge candidate of c (=BMC(c)) must have with MSC(c)<br/>Constraint: fires.thresholdBMC &gt;= 0.</dd>
<dt>
<tt>-fires.thresholdMSC</tt>
</dt>
<dd>threshold for the minimal number of Most Similar Clusters (MSCs)<br/>Constraint: fires.thresholdMSC &gt;= 1.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.distance.distancefunction.FileBasedDoubleDistanceFunction}</dt>
<dd>
<dl>
<dt>
<tt>-distance.matrix</tt>
</dt>
<dd>The name of the file containing the distance matrix.</dd>
<dt>
<tt>-distance.parser</tt>
</dt>
<dd>Parser used to load the distance matrix.<br/>Implementing de.lmu.ifi.dbs.elki.parser.DistanceParserDefault: de.lmu.ifi.dbs.elki.parser.NumberDistanceParser.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.DependencyDerivator}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-derivator.accuracy</tt>
</dt>
<dd>Threshold for output accuracy fraction digits.<br/>Default: 4.<br/>Constraint: derivator.accuracy &gt;= 0.</dd>
<dt>
<tt>-derivator.randomSample</tt>
</dt>
<dd>Flag to use random sample (use knn query around centroid, if flag is not set).</dd>
<dt>
<tt>-derivator.sampleSize</tt>
</dt>
<dd>Threshold for the size of the random sample to use. Default value is size of the complete dataset.<br/>Constraint: derivator.sampleSize &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-derivator.accuracy</tt>
</dt>
<dd>Threshold for output accuracy fraction digits.<br/>Default: 4.<br/>Constraint: derivator.accuracy &gt;= 0.</dd>
<dt>
<tt>-derivator.randomSample</tt>
</dt>
<dd>Flag to use random sample (use knn query around centroid, if flag is not set).</dd>
<dt>
<tt>-derivator.sampleSize</tt>
</dt>
<dd>Threshold for the size of the random sample to use. Default value is size of the complete dataset.<br/>Constraint: derivator.sampleSize &gt; 0.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.algorithm.clustering.SLINK}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.math.linearalgebra.pca.WeakEigenPairFilter}</dt>
<dd>
<dl>
<dt>
<tt>-pca.filter.weakalpha</tt>
</dt>
<dd>The minimum strength of the statistically expected variance (1/n) share an eigenvector needs to have to be considered 'strong'.<br/>Default: 0.95.<br/>Constraint: pca.filter.weakalpha &gt;= 0.0.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.wrapper.DiSHWrapper}</dt>
<dd>
<dl>
<dt>
<tt>-dbc.in</tt>
</dt>
<dd>The name of the input file to be parsed.</dd>
<dt>
<tt>-dish.epsilon</tt>
</dt>
<dd>The maximum radius of the neighborhood to be considered in each dimension for determination of the preference vector.<br/>Default: 0.0010.<br/>Constraint: dish.epsilon &gt;= 0.</dd>
<dt>
<tt>-dish.mu</tt>
</dt>
<dd>The minimum number of points as a smoothing factor to avoid the single-link-effekt.<br/>Default: 10.<br/>Constraint: dish.mu &gt; 0.</dd>
<dt>
<tt>-dish.strategy</tt>
</dt>
<dd>the strategy for determination of the preference vector, available strategies are: [APRIORI| MAX_INTERSECTION](default is MAX_INTERSECTION)<br/>Default: MAX_INTERSECTION.<br/>Constraint: dish.strategy in [APRIORI, MAX_INTERSECTION].</dd>
<dt>
<tt>-h</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-help</tt>
</dt>
<dd>Request a help-message, either for the main-routine or for any specified algorithm. Causes immediate stop of the program.</dd>
<dt>
<tt>-out</tt>
</dt>
<dd>Directory name (or name of an existing file) to write the obtained results in. If this parameter is omitted, per default the output will sequentially be given to STDOUT.</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link de.lmu.ifi.dbs.elki.index.tree.metrical.mtreevariants.mktrees.mkcop.MkCoPTree}</dt>
<dd>
<dl>
<dt>
<tt>-mkcop.k</tt>
</dt>
<dd>positive integer specifying the maximal number k of reversek nearest neighbors to be supported.<br/>Constraint: mkcop.k &gt; 0.</dd>
<dt>
<tt>-mtree.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-treeindex.cachesize</tt>
</dt>
<dd>The size of the cache in bytes.<br/>Default: 2147483647.<br/>Constraint: treeindex.cachesize &gt;= 0.</dd>
<dt>
<tt>-treeindex.file</tt>
</dt>
<dd>The name of the file storing the index. If this parameter is not set the index is hold in the main memory.</dd>
<dt>
<tt>-treeindex.pagesize</tt>
</dt>
<dd>The size of a page in bytes.<br/>Default: 4000.<br/>Constraint: treeindex.pagesize &gt; 0.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.lisa.GridBasedROS}</dt>
<dd>
<dl>
<dt>
<tt>-algorithm.distancefunction</tt>
</dt>
<dd>Distance function to determine the distance between database objects.<br/>Implementing de.lmu.ifi.dbs.elki.distance.distancefunction.DistanceFunction<br/>Known classes (default package de.lmu.ifi.dbs.elki.distance.distancefunction.):<br/>-&gt; CosineDistanceFunction<br/>-&gt; DimensionSelectingDistanceFunction<br/>-&gt; DimensionsSelectingEuclideanDistanceFunction<br/>-&gt; DirectSupportDependentItemsetDistanceFunction<br/>-&gt; EuclideanDistanceFunction<br/>-&gt; ERiCDistanceFunction<br/>-&gt; FileBasedDoubleDistanceFunction<br/>-&gt; FileBasedFloatDistanceFunction<br/>-&gt; LPNormDistanceFunction<br/>-&gt; LocallyWeightedDistanceFunction<br/>-&gt; PCABasedCorrelationDistanceFunction<br/>-&gt; DiSHDistanceFunction<br/>-&gt; HiSCDistanceFunction<br/>-&gt; ReciprocalSupportDependentItemsetDistanceFunction<br/>-&gt; RepresentationSelectingDistanceFunction<br/>-&gt; SharedMaximumDistanceFunction<br/>-&gt; SharedUnitedDistanceFunction<br/>-&gt; SquareRootSupportLengthDependentItemsetDistanceFunction<br/>-&gt; SupportLengthDependentItemsetDistanceFunction<br/>-&gt; timeseries.DTWDistanceFunction<br/>-&gt; timeseries.EDRDistanceFunction<br/>-&gt; timeseries.ERPDistanceFunction<br/>-&gt; timeseries.LCSSDistanceFunction<br/>Default: de.lmu.ifi.dbs.elki.distance.distancefunction.EuclideanDistanceFunction.</dd>
<dt>
<tt>-gbros.r</tt>
</dt>
<dd>number of partitions on each axis<br/>Constraint: all elements of gbros.r &lt; 0.</dd>
<dt>
<tt>-rbo.k</tt>
</dt>
<dd>The number of nearest neighbors</dd>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
<dt>{@link experimentalcode.tobias.rknnjoin.RkNNJoin}</dt>
<dd>
<dl>
<dt>
<tt>-time</tt>
</dt>
<dd>Request output of performance time.</dd>
<dt>
<tt>-verbose</tt>
</dt>
<dd>Enable verbose messages while performing the algorithm.</dd>
</dl>
</dd>
</dl>
</body>
</html>
