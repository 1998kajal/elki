package experimentalcode.students.reichertl.hopkinsStatistic;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Random;

import de.lmu.ifi.dbs.elki.algorithm.AbstractPrimitiveDistanceBasedAlgorithm;
import de.lmu.ifi.dbs.elki.data.NumberVector;
import de.lmu.ifi.dbs.elki.data.type.TypeInformation;
import de.lmu.ifi.dbs.elki.data.type.TypeUtil;
import de.lmu.ifi.dbs.elki.database.Database;
import de.lmu.ifi.dbs.elki.database.ids.DBIDIter;
import de.lmu.ifi.dbs.elki.database.ids.DBIDUtil;
import de.lmu.ifi.dbs.elki.database.ids.ModifiableDBIDs;
import de.lmu.ifi.dbs.elki.database.query.distance.DistanceQuery;
import de.lmu.ifi.dbs.elki.database.query.knn.KNNQuery;
import de.lmu.ifi.dbs.elki.database.relation.Relation;
import de.lmu.ifi.dbs.elki.database.relation.RelationUtil;
import de.lmu.ifi.dbs.elki.distance.distancefunction.PrimitiveDistanceFunction;
import de.lmu.ifi.dbs.elki.distance.distancevalue.NumberDistance;
import de.lmu.ifi.dbs.elki.logging.Logging;
import de.lmu.ifi.dbs.elki.math.MeanVariance;
import de.lmu.ifi.dbs.elki.result.CollectionResult;
import de.lmu.ifi.dbs.elki.result.Result;
import de.lmu.ifi.dbs.elki.utilities.DatabaseUtil;
import de.lmu.ifi.dbs.elki.utilities.datastructures.arraylike.ArrayLikeUtil;
import de.lmu.ifi.dbs.elki.utilities.optionhandling.OptionID;
import de.lmu.ifi.dbs.elki.utilities.optionhandling.constraints.AllOrNoneMustBeSetGlobalConstraint;
import de.lmu.ifi.dbs.elki.utilities.optionhandling.constraints.EqualSizeGlobalConstraint;
import de.lmu.ifi.dbs.elki.utilities.optionhandling.parameterization.Parameterization;
import de.lmu.ifi.dbs.elki.utilities.optionhandling.parameters.DoubleListParameter;
import de.lmu.ifi.dbs.elki.utilities.optionhandling.parameters.IntParameter;
import de.lmu.ifi.dbs.elki.utilities.optionhandling.parameters.LongParameter;
import de.lmu.ifi.dbs.elki.utilities.pairs.Pair;

/**
 * The Hopkins Statistic measures the probability that a dataset is generated by
 * a uniform data distribution. Data Mining Concepts and Techniques S. 484-485
 * 
 * @author Lisa Reichert
 * 
 * 
 * @param <O> Database object type
 * @param <D> Distance type
 */
public class HopkinsStatistic<V extends NumberVector<?>, D extends NumberDistance<D, ?>> extends AbstractPrimitiveDistanceBasedAlgorithm<V, D, Result> {
  /**
   * The logger for this class.
   */
  private static final Logging logger = Logging.getLogger(HopkinsStatistic.class);

  public static final OptionID SAMPLESIZE_ID = new OptionID("hopkins.samplesize", "List of the size of datasamples");

  /**
   * The parameter sampleSizes
   */
  private int sampleSize;

  /**
   * Parameter to specify the number of repetitions of computing the hopkins
   * value.
   */
  public static final OptionID REP_ID = new OptionID("hopkins.rep", "The number of repetitions.");

  private int rep;

  /**
   * Parameter to specify the random generator seed.
   */
  public static final OptionID SEED_ID = new OptionID("hopkins.seed", "The random number generator seed.");

  /**
   * Holds the value of {@link #SEED_ID}.
   */
  private Long seed;

  /**
   * Parameter for minimum.
   */
  public static final OptionID MINIMA_ID = new OptionID("hopkins.min", "a comma separated concatenation of the minimum values in each dimension. If no value is specified, the minimum value of the attribute range in this dimension will be taken. If only one value is specified, this value will be taken for all dimensions.");

  /**
   * Parameter for maximum.
   */
  public static final OptionID MAXIMA_ID = new OptionID("hopkins.max", "a comma separated concatenation of the maximum values in each dimension. If no value is specified, the maximum value of the attribute range in this dimension will be taken.  If only one value is specified, this value will be taken for all dimensions.");

  /**
   * Stores the maximum in each dimension.
   */
  private double[] maxima = new double[0];

  /**
   * Stores the minimum in each dimension.
   */
  private double[] minima = new double[0];

  public HopkinsStatistic(PrimitiveDistanceFunction<? super V, D> distanceFunction, int samplesize, Long seed, int rep, double[] minima, double[] maxima) {
    super(distanceFunction);
    this.sampleSize = samplesize;
    this.seed = seed;
    this.rep = rep;
    this.minima = minima;
    this.maxima = maxima;
  }

  /**
   * Runs the algorithm in the timed evaluation part.
   */
  public HopkinsResult run(Database database, Relation<V> relation) {

    final Random masterRandom = (this.seed != null) ? new Random(this.seed) : new Random();
    ArrayList<String> res = new ArrayList<>();

    int dim = RelationUtil.dimensionality(relation);
    final DistanceQuery<V, D> distanceQuery = database.getDistanceQuery(relation, getDistanceFunction());
    KNNQuery<V, D> knnQuery = database.getKNNQuery(distanceQuery, 2);

    MeanVariance hmean = new MeanVariance();
    MeanVariance umean = new MeanVariance();
    MeanVariance wmean = new MeanVariance();
    // compute the hopkins value several times and use the average value for a
    // more stable result
    for(int j = 0; j < this.rep; j++) {
      // compute NN distances for random objects from within the database
      ModifiableDBIDs dataSampleIds = DBIDUtil.randomSample(relation.getDBIDs(), sampleSize, masterRandom.nextLong());
      DBIDIter iter2 = dataSampleIds.iter();
      // k= 2 und dann natürlich 2. element aus liste holen sonst nächster
      // nachbar
      // von q immer q
      double w = knnQuery.getKNNForDBID(iter2, 2).get(1).getDistance().doubleValue();
      iter2.advance();
      for(; iter2.valid(); iter2.advance()) {
        w += knnQuery.getKNNForDBID(iter2, 2).get(1).getDistance().doubleValue();
      }
      // compute NN distances for randomly created new uniform objects
      Collection<V> uniformObjs = getUniformObjs(relation, masterRandom.nextLong(), sampleSize, this.minima, this.maxima, dim);
      Iterator<V> iter = uniformObjs.iterator();
      double u = knnQuery.getKNNForObject(iter.next(), 1).get(0).getDistance().doubleValue();
      while(iter.hasNext()) {
        u += knnQuery.getKNNForObject(iter.next(), 1).get(0).getDistance().doubleValue();
      }
      // compute hopkins statistik
      double h = u / (u + w);
      hmean.put(h);
      umean.put(u);
      wmean.put(w);
    }
    String r = "samplesize " + sampleSize + " dim " + dim + " hopkins mean: " + hmean.getMean() + " hopkins variance: " + hmean.getSampleVariance() + " umean " + umean.getMean() + " uvar " + umean.getSampleVariance() + " wmean " + wmean.getMean() + " wvar " + wmean.getSampleVariance();
    res.add(r);

    return new HopkinsResult(res, this.sampleSize + "samples");
  }

  public <T extends V> Collection<V> getUniformObjs(Relation<V> relation, Long random, int sampleSize, double[] min, double[] max, int dim) {
    logger.debug("min" + min.length + "max" + max.length + "dim" + dim);
    ArrayList<V> result = new ArrayList<>(sampleSize);
    double[] vec = new double[dim];
    Random[] randoms = new Random[dim];
    for(int i = 0; i < randoms.length; i++) {
      randoms[i] = new Random(random);
    }

    final NumberVector.Factory<V, ?> factory = RelationUtil.getNumberVectorFactory(relation);
    // if no parameter for min max compute min max values for each dimension
    // from dataset
    if(min == null || max == null || min.length == 0 || max.length == 0) {
      Pair<V, V> minmax = DatabaseUtil.computeMinMax(relation);
      min = new double[dim];
      max = new double[dim];
      for(int d = 0; d < dim; d++) {
        min[d] = minmax.first.doubleValue(d);
        max[d] = minmax.second.doubleValue(d);
      }
    }
    // if only one value for all dimensions set this value for each dimension
    if(min.length == 1 || max.length == 1) {
      double val = min[0];
      min = new double[dim];
      for(int i = 0; i < dim; i++) {
        min[i] = val;
      }
      val = max[0];
      max = new double[dim];
      for(int i = 0; i < dim; i++) {
        max[i] = val;
      }
    }
    // compute uniform objects
    for(int i = 0; i < sampleSize; i++) {
      for(int d = 0; d < dim; d++) {
        vec[d] = min[d] + (randoms[d].nextDouble() * (max[d] - min[d]));
      }
      V newp = factory.newNumberVector(vec);
      result.add(newp);
    }

    return result;
  }

  @Override
  protected Logging getLogger() {
    return logger;
  }

  @Override
  public TypeInformation[] getInputTypeRestriction() {
    return TypeUtil.array(getDistanceFunction().getInputTypeRestriction());
  }

  public static class HopkinsResult extends CollectionResult<String> {

    /**
     * Constructor.
     * 
     * @param hopkins result value Hopkinsstatistic
     */
    public HopkinsResult(Collection<String> hopkinsResult, String inputs) {
      super("Hopkinsstatistic", "hopkins" + inputs, hopkinsResult);
    }

  }

  /**
   * Parameterization class.
   * 
   * @author Lisa Reichert
   * 
   * @apiviz.exclude
   */
  public static class Parameterizer<V extends NumberVector<?>, D extends NumberDistance<D, ?>> extends AbstractPrimitiveDistanceBasedAlgorithm.Parameterizer<V, D> {

    protected int sampleSize;

    protected List<Integer> dimensions;

    protected int rep;

    protected Long seed;

    protected String datalocation;

    /**
     * Stores the maximum in each dimension.
     */
    private double[] maxima = new double[0];

    /**
     * Stores the minimum in each dimension.
     */
    private double[] minima = new double[0];

    @Override
    protected void makeOptions(Parameterization config) {
      super.makeOptions(config);

      IntParameter r = new IntParameter(REP_ID, 1);
      if(config.grab(r)) {
        rep = r.getValue();
      }
      else {
        rep = r.getDefaultValue();
      }

      IntParameter sample = new IntParameter(SAMPLESIZE_ID);
      if(config.grab(sample)) {
        sampleSize = sample.getValue();
      }

      // FIXME: use RandomParameter instead.
      final LongParameter seedP = new LongParameter(SEED_ID);
      seedP.setOptional(true);
      if(config.grab(seedP)) {
        seed = seedP.getValue();
      }
      DoubleListParameter minimaP = new DoubleListParameter(MINIMA_ID, true);
      if(config.grab(minimaP)) {
        minima = ArrayLikeUtil.toPrimitiveDoubleArray(minimaP.getValue());
      }
      DoubleListParameter maximaP = new DoubleListParameter(MAXIMA_ID, true);
      if(config.grab(maximaP)) {
        maxima = ArrayLikeUtil.toPrimitiveDoubleArray(maximaP.getValue());
      }

      config.checkConstraint(new AllOrNoneMustBeSetGlobalConstraint(minimaP, maximaP));
      config.checkConstraint(new EqualSizeGlobalConstraint(minimaP, maximaP));
    }

    @Override
    protected HopkinsStatistic<V, D> makeInstance() {
      return new HopkinsStatistic<>(distanceFunction, sampleSize, seed, rep, minima, maxima);
    }
  }
}
