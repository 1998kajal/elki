<html>
<head>
<title>ELKI: Environment for DeveLoping KDD-Applications Supported by Index-Structures</title>
</head>
<body>
<p>ELKI: Environment for DeveLoping KDD-Applications Supported by Index-Structures.</p>

<p>ELKI is a generic framework for a broad range of KDD-applications
and their development.
For background, contact-information, and contributors see
<a href="http://www.dbs.ifi.lmu.de/research/KDD/ELKI/" target="_parent">http://www.dbs.ifi.lmu.de/research/KDD/ELKI/</a>.</p>

<p>This is the documentation for version 0.3, published as:<br />
 <i>Achtert, E., Kriegel, H.-P., Reichert, L., Schubert, E., Wojdanowski, R., and Zimek, A.:<br /> 
  Visual Evaluation of Outlier Detection Models.<br /> 
  In Proc. 15th International Conference on Database Systems for Advanced Applications (DASFAA), Tsukuba, Japan, 2010.</i>
</p>


<h2>Workflow - Where Do Which Objects Go?</h2>
<p>The database connection manages reading of input files or databases and provides a {@link de.lmu.ifi.dbs.elki.database.Database Database}-Object as a virtual database to the KDDTask.
The KDDTask applies a specified algorithm on this database and collects the result from the algorithm.
Finally, KDDTask hands on the obtained result to a {@link de.lmu.ifi.dbs.elki.result.ResultHandler ResultHandler}.
The default-handler is  {@link de.lmu.ifi.dbs.elki.result.ResultWriter ResultWriter}, writing the result to STDOUT or,
if specified, into a file.</p>

<!-- <p align="center"><img src="figures/passingOfObjects.png" alt="visualization of passing of objects" border="1" width="70%"></p> -->

<h3>Database and indexing layer</h3>
<p>The database and indexing layer is a key component of ELKI.
This is not just a storage for <code>double[]</code>, as with many other frameworks.
Instead the integrated index structures provide access to fast
{@link de.lmu.ifi.dbs.elki.database.query.distance.DistanceQuery distance},
{@link de.lmu.ifi.dbs.elki.database.query.similarity.SimilarityQuery similarity},
{@link de.lmu.ifi.dbs.elki.database.query.knn.KNNQuery kNN},
{@link de.lmu.ifi.dbs.elki.database.query.rknn.RKNNQuery RkNN} and
{@link de.lmu.ifi.dbs.elki.database.query.range.RangeQuery range} query methods.</p>
<p>The standard flow for initializing a database is as depicted here:<br />
<img src="figures/database-initialization.png" width="600" height="341" alt="Database initialization" /><br />
The standard stream-based data sources such as
{@link de.lmu.ifi.dbs.elki.datasource.FileBasedDatabaseConnection FileBasedDatabaseConnection}
will open the stream, feed the contents through a
{@link de.lmu.ifi.dbs.elki.datasource.parser.Parser Parser} to obtain an initial
{@link de.lmu.ifi.dbs.elki.datasource.bundle.MultipleObjectsBundle MultipleObjectsBundle}. This is
a <em>temporary</em> container for the data, which can then be modified by arbitrary
{@link de.lmu.ifi.dbs.elki.datasource.filter.ObjectFilter ObjectFilter}s.<br />
In the end, the
{@link de.lmu.ifi.dbs.elki.datasource.bundle.MultipleObjectsBundle MultipleObjectsBundle}
is bulk-inserted into a {@link de.lmu.ifi.dbs.elki.database.Database Database}, which will then
invoke its {@link de.lmu.ifi.dbs.elki.index.IndexFactory IndexFactory}s to add
{@link de.lmu.ifi.dbs.elki.index.Index Index} instances to the appropriate relations.</p>
<p>When a request for a
{@link de.lmu.ifi.dbs.elki.database.query.distance.DistanceQuery distance},
{@link de.lmu.ifi.dbs.elki.database.query.similarity.SimilarityQuery similarity},
{@link de.lmu.ifi.dbs.elki.database.query.knn.KNNQuery kNN},
{@link de.lmu.ifi.dbs.elki.database.query.rknn.RKNNQuery RkNN} or
{@link de.lmu.ifi.dbs.elki.database.query.range.RangeQuery range} query is received by the database,
it queries all indexes if they have support for this query. If so, an optimized query is returned,
otherwise a linear scan query can be returned unless
{@link de.lmu.ifi.dbs.elki.database.query.DatabaseQuery#HINT_OPTIMIZED_ONLY DatabaseQuery.HINT_OPTIMIZED_ONLY}
was given.</p>
<p>For this optimization to work, you should be using the proper APIs of the
{@link de.lmu.ifi.dbs.elki.database.Database Database} interface or
{@link de.lmu.ifi.dbs.elki.database.QueryUtil QueryUtil} helper where possible, instead of
initializing low level classes such as an explicit linear scan query.</p>
<p>For efficiency, try to instantiate the query only once per algorithm run, and avoid running the
optimization step for every object.</p>

<h3>Parameterization API</h3>
<p>ELKI is designed for command-line, GUI and Java operation. For command-line and GUI, an extensive
help functionality is provided along with input assistance. Therefore, you should also support the
parameterizable API. The requirements are quite different from regular Java constructors, and cannot
be expressed in terms of a Java API.</p>
<p>For useful error reporting and input assistance in the GUI we <em>need</em> to have more extensive
typing than Java uses (for example we might need numerical constraints) and we also want to be able
to <em>report more than one error at a time</em>. In ELKI 0.4, much of the parameterization was
refactored to static helper classes usually found as a <tt>public static class Parameterizer</tt>
and subclasses of
{@link de.lmu.ifi.dbs.elki.utilities.optionhandling.AbstractParameterizer AbstractParameterizer}.</p>
<p><img src="figures/parameterization.png" width="600" height="213" alt="Parameterization" /></p>
<p>Keep the complexity of Parameterizer classes and constructors invoked by these classes low, since
these may be heavily used during the parameterization step. Postpone any extensive initialization
to the main algorithm invocation step!</p>

<h2>How to make use of this framework</h2>

<h3>Extension</h3>
To provide new applications one is simply to implement the specified interfaces.
There are interfaces for a broad range of targets of development. Compare the
<a href="overview-tree.html">tree of interfaces</a> to get an overview
concerning the provided interfaces.

<h2>Usage</h2>
<p>To use the KDD-Framework we recommend an executable .jar-file:
<a href="../elki.jar">elki.jar</a>. Since release 0.3 it will by default invoke a minimalistic GUI when
you call <code>java -jar elki.jar</code>. For command line use, you get a description of usage by calling
<code>java -cp elki.jar de.lmu.ifi.dbs.elki.application.KDDCLIApplication -h</code>.</p>

<p>You can read more about the <a href="minigui.html">MiniGUI and Visualizations on a separate page</a>.
The {@link de.lmu.ifi.dbs.elki.application.visualization.KNNExplorer KNNExplorer} application published
with ELKI 0.2 is explained in the technical documentation.</p>

<h3>Parameters and Parameter-Passing</h3>
<p>The core class is {@link de.lmu.ifi.dbs.elki.KDDTask KDDTask} for command line interaction.
This class' main method manages the reading of parameters from the standard input and passes the parameters to the
corresponding classes which, in turn, could have parameters that expect parameterization.</p>

<p>The main class {@link de.lmu.ifi.dbs.elki.KDDTask KDDTask} requires specification of an
{@link de.lmu.ifi.dbs.elki.algorithm.Algorithm Algorithm}
to use, and a {@link de.lmu.ifi.dbs.elki.datasource.DatabaseConnection DatabaseConnection} to manage the input.
It can get assigned a specialized {@link de.lmu.ifi.dbs.elki.result.ResultHandler ResultHandler}.
The default ResultHandler {@link de.lmu.ifi.dbs.elki.result.ResultWriter ResultWriter} expects
a filename where to deploy the output. However, by omitting specification of a filename for
output, the results will be given to standard output, thus it may be piped directly to another
application.</p>

<p>For more information on using files and available formats
as data input see {@link de.lmu.ifi.dbs.elki.datasource.parser}.</p>

<p>Furthermore a normalization can be specified for the input.
You can additionally require to restore the original values for the output.</p>

<p>Which input is to be provided in what way
is to be defined via parameters specifically for a certain
{@link de.lmu.ifi.dbs.elki.datasource.DatabaseConnection DatabaseConnection}.</p>

<p>The need for other parameters may differ from implementation to implementation. However,
you need not to specify input nor output if you are going to implement an algorithm.</p>

<p>An extensive list of parameters can be browsed <a href="parameters-byclass.html">sorted by class</a>
or <a href="parameters-byopt.html">sorted by option ID</a>.</p>

<p>Some examples of completely parameterized calls for different algorithms are described
at <a href="examplecalls.html">example calls</a>.
</p>

<p>A list of related articles can be found in the <a href="references.html">class article references list</a>.</p>

</body>
</html>